<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[shell script 入门]]></title>
    <url>%2F2018%2F12%2F15%2Fshell%20script%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[为什么学shell操作系统其实是一组软件，控制整个计算机硬件如cpu调度，内存、磁盘存储输入输出是操作系统的内核（Kernel）。通常这组软件是不允许被没有管理能力的终端用户随便使用的，但总是需要让用户操作系统的，用户可以通过壳程序（shell）来达到目的。壳程序是提供给用户去操作系统的一个接口，像ls、mkdir这些常用的命令都是封装好的独立应用程序，它们可以利用壳程序再通过内核去操作系统。 linux 很多地方都利用了shell script，shell 在系统管理是很好的工具，服务的启动关闭就是通过它来控制的。所以学习shell 有助于弄清楚linux的来龙去脉，是进一步理解linux的方式。 但是shell script 不擅长大量数值运算，它调用外部函数库耗cpu。linux 默认的shell 是bash，它规范了接口的语法。学习shell 可以参考 认识和学习bash 学习shell scripts shell 操作环境利用系统提供的命令如，ls/mkdir/rm/mv 等，或者通过./xx.sh 执行已写好的可执行脚本。必须先搞清楚系统查询执行这些命令的顺序，所以在当前目录执行脚本文件时要加 ./ 代表相对，否则报找不到文件错误 以相对/绝对路径运行命令，例如『 /bin/ls 』或『 ./ls 』； 由 alias 找到该命令来运行； 由 bash 内建的 (builtin) 命令来运行； 透过 $PATH 这个变量的顺序搜寻到的第一个命令来运行。 我们一登入linux 进入shell 之后，能使用一堆有用的变量，这是因为系统有一些环境配置文件的存在。bash 在启动时直接就读取这些配置文件，以规划好bash 的操作环境。配置文件有分全体系统的配置文件以及用户个人偏好设置文件。 /etc/profile 系统整体的配置 ~/.bash_profile ~/.bash_login ~/.profile 属于使用者个人配置 同时也必须理解login shell 和 non-login shell 的概念，因为通过这两种进入的bash 环境，读取配置文件的顺序不同。 login shell，取得bash 需要完整的登录流程，比如通过secureCRT ssh 方式得到的bash 环境。 non-login shell，取得bash 接口的方法不需要重复的登陆举动，比如你在原本的bash 环境再次下达bash 命令，没有输入账号密码，那第二个bash 子程序也是non-login shell。所以在写脚本命令前一般都会配置环境变量 下面是这两种方式读取配置文件的顺序，图来自鸟哥书籍。实线是主线流程，虚线是被调用的配置文件。图中是login shell 完整顺序图，而non-login shell 只读 ~/.bashrc 简单 shell script下面是简单shell script 的格式，PATH 很重要1234567891011121314#!/bin/bash# Program:# This program is a easy shell script# History:# 2019/07/23 lics First releasePATH=/usr/local/php/bin:/usr/local/node/bin:/usr/localexport PATH# 文件名date=$(date +%Y%m%d)file=$&#123;date&#125;# file 加不加&#123;&#125;只是习惯问题touch &quot;$file&quot; shell script 运行区别 sh script 或者 ./script ，利用直接运行的方式运行script，该script 都会使用一个新的bash 环境来运行脚本内的命令。script 是指子程序的bash 内运行的！注意的是，在子程序的各项变量或者动作将会结束而不会回到父程序中。 source script ，在父程序中运行脚本，script 的各项动作都会在父程序中生效。所以我们修改了/etc/profile 里面的环境变量时，都会运行source /etc/profile 使其有效，否则要重新登入才行。 exec 方式 bash 语法在了解shell 的作用，操作环境，运行方式之后，可以进一步学习bash的基本语法。比如 bash 变量 bash 通配符和特殊符号 ()代表中间为子shell 的起始和结束 判断式，关于文件类型，文件权限，整数，字符串 shell script 的默认变量 $0，$1 $# ：代表后接的参数『个数』，以上表为例这里显示为『 4 』； $@ ：代表『 “$1” “$2” “$3” “$4” 』之意 $* ：代表『 “$1c$2c$3c$4” 』，其中 c 为分隔字节，默认为空白键 条件判断式，if–then/case—esac/function 回圈，while–do/for—-do 定时服务器脚本通过一些例子来熟悉shell script， 写一个定时同步服务器时间的 script 和网络时间同步 12345678# 安装ntpdate工具yum -y install ntp ntpdate# 设置系统时间与网络时间同步ntpdate cn.pool.ntp.org# 将系统时间写入硬件时间hwclock --systohc 定时同步，利用crontab 来执行定时脚本 1234567# 编辑crontabvim /etc/crontab# 添加定时任务，每6分钟同步一次*/10 * * * * ntpdate -u ntp.api.bz &amp;&amp; clock -wservice crond reload 自动连接mysql每次都要通过输入密码连接数据库，难免烦躁，可以把数据库密码放在每个文件中，然后写script 连接12345# 创建con_mysql脚本文件，密码在/data/save/mysql_root 内exec mysql -uroot -p$(cat /data/save/mysql_root) # 把con_mysql 所在目录添置PATH，在任何目录执行con_mysql 数据自动入库假如现在有很多.sql 和txt 文件数据要录入数据库中，我们可以写一个只要提供数据库名、文件所在目录名就可以完成目的的shell script。运行方式 [script] db_name [sql所在目录绝对路径]12345678910111213141516#!/bin/bashdatabase=$1backup_dir=$2if [ "$database" == "" -o "$backup_dir" == "" ] ; then echo "eg:bash $0 db_name data_dir" exitfimysql -uroot -p`cat /data/save/mysql_root` -e "CREATE DATABASE IF NOT EXISTS $&#123;database&#125;;"cd $&#123;backup_dir&#125;SQL_LIST=$(ls $&#123;backup_dir&#125; | /bin/grep sql)for sql_file in $&#123;SQL_LIST&#125;; do mysql -uroot -p`cat /data/save/mysql_root` $&#123;database&#125; &lt; $&#123;sql_file&#125;donemysqlimport --local -uroot -p`cat /data/save/mysql_root` $&#123;database&#125; *.txt script 更新项目版本在项目开发中，项目版本更新过程一般如下 本地环境完成，自测无误 将代码push github 在内测机器pull 项目，进行测试 在我们push 仓库后，每次都要手动去更新内测机器的代码，难免烦躁。可以写一个可视化操作界面，只需点击一个按钮，利用shell script 来完成git pull 和更新到内测机器相应项目目录的步骤 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>基础</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式和单件模式]]></title>
    <url>%2F2018%2F12%2F10%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式每次用new来实例化对象的时候，都是实例化具体的类，不是面向接口编程，而是实现；代码绑着具体类会导致代码更脆弱，更缺乏弹性，初始化也经常造成耦合的问题。 假设现在有家披萨Pizza 店，有很多披萨比如pizzaA、pizzaB、pizzaC、pizzaD，产生披萨的类一开始可能会这样写1234567891011121314151617181920212223Pizza orderPizza(String type)&#123; // Pizza 抽象类 ABCDE 是实现子类 Pizza pizza; if(type.equals("A"))&#123; pizza = new pizzaA(); &#125;else if(type.equals("B"))&#123; pizza = new pizzaB(); &#125;else if(type.equals("C"))&#123; pizza = new pizzaC(); &#125;else if(type.equals("D"))&#123; pizza = new pizzaD(); &#125;else if(type.equals("E"))&#123; pizza = new pizzaE(); &#125; // 披萨的其他加工步骤 pizza.prepare(); pizza.bake(); //烘烤 pizza.cut(); //切片 pizza.box(); //装盒 return pizza;&#125; 这个设计显然违背了 封闭——开放原则，如果pizza 种类增多，或者要去除一些不受欢迎的披萨，就必须修改orderPizza ，而这都是没有对变化封闭的原因。于是我们把创建pizza 那边代码搬移到简单的工厂SimplePizzaFactory123456789101112131415161718192021222324252627282930313233343536public class SimplePizzaFactory&#123; public Pizza createPizza(String type)&#123; // Pizza 抽象类 ABCDE 是实现子类 Pizza pizza = null; if(type.equals("A"))&#123; pizza = new pizzaA(); &#125;else if(type.equals("B"))&#123; pizza = new pizzaB(); &#125;else if(type.equals("C"))&#123; pizza = new pizzaC(); &#125;else if(type.equals("D"))&#123; pizza = new pizzaD(); &#125;else if(type.equals("E"))&#123; pizza = new pizzaE(); &#125; return pizza; &#125;&#125;// 修改 orderPizzapublic class PizzaStore&#123; SimplePizzaFactory factory; public PizzaStore(SimplePizzaFactory factory)&#123; this.factory = factory; &#125; public Pizza orderPizza(String type)&#123; Pizza pizza; pizza = factory.createPizza(type); // pizza 的其他方法 &#125;&#125; 我们来看一下引入这个简单工厂的类图设计， 上面只是一个简单的工厂设计，如果披萨店变得很多了怎么办，createPizza应该生产哪家披萨店的披萨呢？我们可以把pizzaStore 设计成一个抽象类123456789101112131415161718192021222324252627282930public abstract Class PizzaStore &#123; public Pizza orderPizza(String type)&#123; Pizza pizza; pizza = createPizza(type); pizza.prepare(); pizza.bake(); // pizza 其他制作方法 return pizza &#125; // createPiza 决定生产那个店的披萨，父类的orderPizza 和子类createPizza 解耦 abstract Pizza createPizza(String type);&#125;//披萨店Apubic class storeAPizzaStore extends PizzaStore&#123; Pizza createPizza(String type)&#123; if(type.equals("A"))&#123; return new storeApizzaA(); &#125;else if(type.equals("B"))&#123; return new storeApizzaB(); &#125;else if(type.equals("C"))&#123; return new storeApizzaC(); &#125;else if(type.equals("D"))&#123; return new storeApizzaD(); &#125; &#125;&#125; 在看看工厂方法的定义1abstract Product factoryMethod(String type) 工厂方法用来处理对象的创建，并将这样的行为封装在子类中。这样，客户程序中关于超类的代码就和子类对象创建代码解耦了。 工厂方法是抽象，依赖子类实现对象创建 工厂方法必须返回一个产品 工厂方法将客户代码和实际创建具体产品的代码分隔开 参数看情况是否需要 这样披萨的制作过程代码就是12345pizzaStore storeA = new storeAPizzaStore();Pizaa storeAPizzaB = storeA.orderPizza(&apos;B&apos;);pizzaStore storeB = new storeBPizzaStore();Pizaa storeBPizzaB = storeB.orderPizza(&apos;B&apos;); 再来看看利用该复杂工厂的设计类图， 单件模式在软件项目里面有些类只能有一个实例，比如线程池、缓存、对话框，日志等对象；如果制作出多个实例就会导致许多问题，比如程序的行为异常、资源使用过量，或者是不一致的结果。下面是一个经典的单件模式实现123456789101112131415161718public class Singleton&#123; private static Singleton uniqueInstance; // 其他有用的变量 // 构造器私有 private Singleton()&#123; // ... &#125; public static Singleton getInstance()&#123; if(uniqueInstance == null)&#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125; // 其他方法&#125; 单件模式就是，确保一个类只有一个实例，并提供一个全局访问点。但是尽管如此，如果是在多线程情况下使用的话，也有可能new 出了多个实例化对象。就是在第一次调用getInstance 创建对象时出了问题。解决多线程安全问题，一般可以这样123456789public static Synchronized Singleton getInstance()&#123; if(uniqueInstance == null)&#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance;&#125;// 或者在声明变量的时候 就实例化private static Singleton uniqueInstance = new Singleton(); 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>改善代码</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
        <tag>单件模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰者模式和命令模式]]></title>
    <url>%2F2018%2F12%2F06%2F%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰者模式现在有一家咖啡连锁店，咖啡如A、B、C、D多种，配料更是有蒸奶（Milk）、豆浆（Soy）、摩卡（Mocha）、奶泡（whip）等，咖啡店会根据加入的配料收取不同的费用。那怎样设计其中的单订系统呢，起初是这样设计的。看类图 其中 Beverage 是各饮料的基类，里面包含变量 描述，各个配料的布尔值，cost 计算配料的价格（该方法是具体的） 子类饮料 BeverageA，设置加入制定配料，重写cost() 方法，并调用父类的cost 计算配料钱，再加上饮料费用，计算出总额。 看起来4 个类就可以解决问题，但是一旦需求变动 调料的价格变动，要修改父类Berverage 代码 一旦出现新的饮料，得为Berverage 加成员变量 喝个冰茶，还得设置其他调料为false，真是麻烦 有人来个 双倍 Milk 调料，怎么办？ 我们对类的设计，没有做到对扩展开发，对修改关闭（开发——关闭原则）。我们的目标是允许类容易扩展，在不修改现有代码的情况下就可搭配新的行为，弹性应对改变的需求。 做到开放-关闭 原则，如观察者模式。不需要每一部分都这样设计，要花费很多时间，关注在设计中最有可能改变的地方应用开放-关闭原则。 如果现在有这样一种设计来实现上面的需求，如下 实现过程 BerverA 是被装饰者，cost() 返回BerverA 的费用 Mocha 是装饰者，cost() 调用BerverA cost ()，返回Mocha、BerverageA 总费用 whip 是装饰者，cost调用Mocha cost()，返回Whip、Mocha、BerverageA 总费用 其中饮料BerverA 继承Berver 饮料基类，Mocah/Whip 继承了装饰者基类（该类已继承Berverage ），类图如下 调料装饰者，除了实现cost之外，还实现了getDescription()，现在看具体代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 组件 饮料 Berveragepublic abstract class Berverage&#123; String description = 'Unkown Berverage'; public String getDescription()&#123; return description; &#125; public abstract double cost();&#125;// 装饰者抽象类 调料public abstract class CondimentDecorator extends Beverage &#123; // 所有调料装饰者 重新实现 getDescription public abastract String getDescription();&#125;// 具体组件 饮料 BeverageApublic class BerverageA extends Beverage &#123; public BerverageA() &#123; // 该变量来自父类 description = 'BeverageA'; &#125; public double cost() &#123; return 3.99; &#125;&#125;// 饮料 BeverageBpublic class BeverageB extends Beverage &#123; public BeverageB() &#123; // 该变量来自父类 description = 'BeverageB'; &#125; public double cost() &#123; return 2.29; &#125;&#125;// 具体装饰者 调料 摩卡（mocha）public class Mocha extends CondimentDcorator &#123; Beverage beverage; // 传入 被装饰者 或者 其他装饰者，利用多态的特性 public Mocha(Beverage beverage) &#123; this.beverage = beverage; &#125; // 重新实现 getDescription 可以连调料都输出 public String getDescription() &#123; return beverage.getDescription + ', Mocha'; &#125; public double cost()&#123; return 1.11 + beverage.cost(); &#125;&#125;// 具体装饰者 调料 蒸奶（Milk）public class Milk extends CondimentDcorator &#123; Beverage beverage; // 传入 被装饰者 或者 其他装饰者，利用多态的特性 public Milk(Beverage beverage) &#123; this.beverage = beverage; &#125; // 重新实现 getDescription 可以连调料都输出 public String getDescription() &#123; return beverage.getDescription + ', Milk'; &#125; public double cost()&#123; return 13.11 + beverage.cost(); &#125;&#125; 就是这样实现装饰者模式的，接下来我们测试一下123456789101112public class Test&#123; public static void main(String args[])&#123; Beverage beverage = new BeverageA(); // 加入调料 摩卡（mocha） beverage = new Mocha(beverage); // 双倍 摩卡（mocha） 哈哈！ beverage = new Mocha(beverage); // 加入 蒸奶（Milk） beverage = new Milk(beverage); System.out.println(beverage.getDescription() + '价格,' + beverage.cost()); &#125;&#125; 以上就是装饰者模式的全部实现了，其定义是，装饰者模式动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承共有弹性的替代方案。 java.io 类 java.io 包内的类太多了，其中很多类都是装饰者，如图用装饰者将功能结合起来以读取文件数据， BufferedInputStream 是一个具体的装饰者，加入缓冲输入改进性能；用realine() 一次读取一行文件增强接口 LineNumberInputStream 也是一个具体的装饰者，加上了计算行数的能力。 命令模式让我们从餐厅订单的工作流程来认识命令模式，顾客在订单上写好菜单，把订单交给女招待；女招待拿了订单就放在订单柜台，然后喊了一句 “单订来了！”；最后厨师就根据单订准备餐点。详细分析过程就是， 顾客知道自己想要什么，createOrder() 创建一份订单 女招待利用 takeOrder()，拿到订单并且调用 orderUp() 方法通知厨师开始准备餐点 厨师根据指令准备餐点 其中以上过程，创建的单订对象里面包含厨师（命令接收者）和告诉厨师的一系列指令，并对外只暴露一个orderUp()通知执行命令；女招待（调用者）根本不关心谁是命令接收者，厨师也不关心被谁触发命令，被谁调用。 我们用遥控器遥控灯泡亮暗的例子来观察代码实现，当我们按下遥控器（调用者）亮灯按钮（命令对象）时，灯（接收者）亮了。命令对象包含了接受者和对接受者的指令，让所有的命令对象实现相同的包含一个方法的接口，在餐厅例子中叫orderUp，一般惯用execute123public interface Command &#123; public void execute();&#125; 现在实现打开电灯的命令，接受者Light 有on() 和 off()123456789101112public class LightOnCommand implements Command &#123; Light light; public LightOnCommand(Light light)&#123; this.light = light; &#125; // 对外暴露 execute 给调用者 public void execute()&#123; light.on(); &#125;&#125; 使用命令对象，假设我们有个遥控器，按下按钮对应的命令对象插槽12345678910111213141516171819202122232425public class SimpleRemoteControl &#123; Command slot; public SimpleRemoteControl()&#123;&#125; public void setCommand(Command command)&#123; slot = command; &#125; public void buttonWasPressed()&#123; slot.execute(); &#125;&#125;// Testpublic class RemoteControlTest &#123; public static void main(String[] args)&#123; SimpleRemoteControl remote = new SimpleRemoteControl(); Light light = new Light(); LightOnCommand ligthOn = new LightOnComand(light); remote.setCommand(lightOn); remote.buttonWasPressed(); &#125;&#125; 以上就是用命令模式实现按下遥控器按钮，下达命令使灯亮的全部代码。命令模式将“请求”封装成对象，以便使用不同的请求、队列来参数化其他对象。 一个命令对象通过在特定接收者上绑定一组动作来封装一个请求。要达到这一点，命令对象将动作和接收者包进对象中，这个对象只暴露出一个execute() 方法，当此方法被调用的时候，接收者就会进行这些动作。从外面来看，其他对象不知道究竟哪个接收者进行了那些动作，只知道如果调用execute()方法，请求的目的就能达到。命令模式类图 laravel 消息队列现有一个日志收集服务系统要接收来自数据埋点的数据，利用laravel 的消息队列来处理请求。处理过程是利用controller 先把真正处理请求函数和数据联系起来，再启动work 进程消费这些任务，最终完成数据入库。利用命令模式来理解这样过程 controller（客户），创建命令对象，把真正处理请求的函数（接受者）和参数用json 字符串保存到redis/mysql work 进程（调用者），可用supervisord 管理启动。读取redis 中命令对象，调用接收者完成任务 真正处理请求的函数（接收者） 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>改善代码</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>装饰者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式和观察者模式]]></title>
    <url>%2F2018%2F12%2F02%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[为什么要设计模式软件开发中，我们花费更多的时间在需求变化和维护项目上，想更好得应对变化需要建立弹性的，可维护、可应对变化的设计。而知道抽象、继承、多态，并不能马上成为面向对象设计者，设计模式正是告诉我们如何组织类和对象以解决某种问题，所以需要设计模式。 其实我们正在使用的框架封装了很多设计模式，但是我们感觉不到。可以先让设计模式进入你的脑海，再尝试使用。 策略模式现在有个模拟鸭子的游戏，游戏中出现各种鸭子，比如一边游泳，一边呱呱叫，每个鸭子的外形不同。使用面向对象（OO）技术，设计类图如下 需求变动，有些鸭子要添加飞的特性，会飞的特性代码添加在哪里呢？ 父类 Duck 的实现代码中，这样会导致全部鸭子都会飞，明显不行。 解决方案，可以把 fly() 覆盖掉，使得鸭子不会飞。但也有鸭子会飞不会叫，采用同样的方法覆盖 quack() 缺点，很难知道鸭子全部行为、代码在多个子类中重复 利用接口，把 fly() quack() 方法接口出去 缺点，此时行为代码写在鸭子子类中，代码无法复用，如果有48个鸭子都要稍微修改一下飞行的行为，很容易出错 上面两种方式都不能解决问题，那是因为我们没有遵循设计原则 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 这样我们可以把飞和叫 的行为抽出成类，独立出去。类图如下 现在父类Duck 中只要 FlyBehaior QuackBehavior 两个行为接口引用就行了，在利用多态特性去调用飞和叫的方法，而且具体的方法实现也不会出现在Duck 或者Duck 子类中。 Duck 代码实现如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public abstract class Duck&#123; FlyBehavior flyBehavior; QuackBehavior quackBehavior; public Duck()&#123; &#125; public void performFly()&#123; flyBehavior.fly(); &#125; public void performQuack()&#123; quackBehavior.quack(); &#125; public void swim()&#123; // ..... &#125;&#125;// 飞行为public interface FlyBehavior&#123; public void fly&#123;&#125;;&#125;public class FlyWithWings implements FlyBehavior &#123; public void fly()&#123; //... &#125;&#125;public class FlyNoWay implements FlyBehavior &#123; public void fly()&#123; // ... &#125;&#125;// 实现 一个鸭子public class MallardDuck extends Duck &#123; public MallardDuck()&#123; quackBehavior = new Quack(); flyBehavior = new FlyWithWings(); &#125; public void dispaly()&#123; // ... &#125;&#125; 这样就可以很方便添加飞行为的其他实现，这时全部类图 当然Duck 也可以提供set flyBehavior实现类的对象，使得鸭子对象在运行时能改变自己飞的行为形式123public void setFlyBehavior(FlyBehavior fb)&#123; flyBehavior = fb;&#125; 策略者模式：定义算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。其实在 重构 优化switch/case 语句中使用的就是策略模式。 观察者模式现在有一个气象站，它是获取湿度、温度、气压数据的物理装置，WeatherData追踪气象站的数据变化，并且更新到报告班板，如图 需求： WeatherData 类有getter 方法，可以取得温度、湿度、气压、三个测量值。当测量数据发送变化时，WeatherData measurementsChanged() 方法就会被调用（先不管它是如何被调用的，只要记住一点数据变化会调用此方法） 需要实现三个布告板，目前状况布告、气象统计布告、天气预报布告；并且系统需可扩展，实现让其他开发人员建立定制的布告板，用户可以随便添加或者删除 任何布告板。 一般我们是这样实现的1234567891011121314public class WeatherData &#123; // 实例变量声明 pubic void measuremetnsChanged()&#123; float temp = getTemperature(); float humidity = getHumidity(); float pressure = getPressure(); currentConditionsDisplay.update(temp, humidity, pressure); statisticsDisplay.update(temp, humidity, pressure); forecastDisplay.update(temp, humidity, pressure); &#125; // 这里WeatherData 其他方法&#125; 这样实现由缺点 对于每个新的布告板，我们都得修改代码，我们尚未封装改变的部分 布告板没有实现一个共同的 接口，至少update 看来参数没有发生变化 我们无法在运行时动态地添加、删除布告板 利用观察者模式来设计，观察者模式就类似在生活中我们 向杂志社订阅或者取消订阅报纸、杂志。结合模型对象的编程思想，杂志社需要提供 订阅、取消订阅、通知用户的方法，而订阅者肯定要提供一个 让杂志社联系上自己的方法。联系上面的需求，画出类图 所以我们可以把实现上面需求的类图设计为 实现代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public interface Subject &#123; public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifybservers();&#125;public interface Observer &#123; public void update(float temp, float humidity, float pressure);&#125;public interface DisplayElement&#123; public void display();&#125;// 实现 weatherDatapublic class WeatherData implements Subject &#123; private ArrayList observers; private float temperature; private float humidity; private float pressure; public WeatherData()&#123; observers = new ArrayList(); &#125; public void registerObserver(Observer o)&#123; observers.add(o); &#125; public void removeObserver(Observer o)&#123; int i = observers.indexof(o); if(i &gt;= 0)&#123; observer.remove(i); &#125; &#125; public void notifyObservers()&#123; for(int i=0; i&lt; observers.size(); i++)&#123; Observer observer = (Observer)observers.get(i); Observer.update(temperature, humidity, pressure); &#125; &#125; // 测量数据改变，该方法会被调用 public void measurementsChanged()&#123; notifyObservers(); &#125;&#125; // 创建布告板 public class CurrentconditionsDisplay implements Observer, DisplayElement &#123; private float temperature; private float humidity; private Subject weatherData; public CurrentconditionsDisplay(Subject weatherdata)&#123; this.weatherData = weatherData; weatherData.registerobserver(this); &#125; public void update (float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; display(); &#125; public void display()&#123; // .... &#125;&#125; 观察者模式，定义了对象之间一对多依赖，当一个对象改变状态，它的所有依赖者都会接收到通知并自动更新 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>改善代码</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过滤垃圾评论]]></title>
    <url>%2F2018%2F11%2F28%2F%E8%BF%87%E6%BB%A4%E5%9E%83%E5%9C%BE%E8%AF%84%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>数据处理</category>
        <category>提取数据特征</category>
      </categories>
      <tags>
        <tag>过滤垃圾评论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重构]]></title>
    <url>%2F2018%2F11%2F25%2F%E9%87%8D%E6%9E%84%2F</url>
    <content type="text"><![CDATA[技术是为了更好得解决变动的需求，要做到这一点，必须写出优雅的代码。这需要重构， 这是一个开发人员从初级到中级的必经之路 重构是目的，设计模式是到达的方式，这需要一直的训练 重构是什么 什么是重构，调整软件内部结构，提高理解性，降低修改成本；但不改变软件可观察行为（功能） 何时重构，不用专门拨时间进行重构，应该是随时随地进行的。当想为程序添加特性，但代码结构使你不是很方便达成目的，可考虑先重构。应该好程序应满足下面条件 容易阅读 所有逻辑都只在唯一地址指定 新的改动不会危及现有行为 尽可能简单表达条件逻辑 重构难题，数据库、修改接口 重构和性能，重构代码有时会为了改善结构而牺牲性能，尽管如此你也不必要求代码处处高性能。一视同仁优化所有代码，90%工作是白费的，你优化的代码很少被运行。所以，编写良好代码结构，不对性能投以特别的关注，直至进入性能优化阶段（后期阶段）。 代码的坏味道 重复代码，提取方法，把方法提取到父类 过长函数，提取方法 难点：怎样解决参数过多的问题 过大的类，提取类或者子类 过长参数列 由于需求变动，导致代码块多处逻辑都修改（不符合逻辑在唯一处）。 依赖情结，类中某方法，太过依赖其他类数据，move it 数据泥团，提取出类 令人迷惑的暂时字段？ 过多的注释，好代码，注释是多余的，写注释前请先尝试重构。 提炼函数（Extract Method） extract Method 难点：源函数参数，局部变量(个数越多，越难extract) 临时变量 Inline Method，不需要extract 函数，提取了之后感觉这一中间层很别扭。 函数体来代替 函数名 查询函数代替临时变量：临时变量局限于某个函数，函数可以在对象整个生命周期中使用。 内联临时变量，引入解释临时变量 1234567891011121314151617181920212223# 内联临时变量let xx = aaa.b;if(xx &gt;21)&#123; dosomething;&#125;&lt;!-- 之后 --&gt;if(aaa.b &gt;21)&#123; dosomething;&#125;# 引入解释临时变量if(aaa.bb.c.indexof(&apos;xx&apos;) &gt; -1 &amp;&amp; ddd.ee.f &gt; -1)&#123; dosomething;&#125;&lt;!-- 之后 --&gt;const a = aaa.bb.c.indexof(&apos;xx&apos;) &gt; -1;const b = ddd.ee.f &gt; -1;if(a &amp;&amp; b)&#123; dosomething;&#125; 分解临时变量，当一个临时变量被赋值了两次，可以引入两个独立 临时变量 i = i + xx 形式不要拆解 拒绝对函数参数赋值 引发很多，函数引用传参的问题，java 更多是提倡按值传递。 js 动态语言，很多都是对象，注意 深拷贝 的问题 类来代替函数（replace method with Object） 当一个函数局部变量很多，逻辑复杂，extract 困难。就把函数升级为类 替换算法，简单逻辑替换复杂逻辑 引入解释临时变量，和抽取函数选择哪一种。 对象之间搬移特性 搬移函数、搬移字段，如果一类里面包含太多行为，或者里面的函数和其他类耦合高，被调用次数比驻类（宿主类）还多。可以考虑搬移函数，搬移之前，往往先进行搬移字段，如果字段被驻类很多函数调用，先进行自我封装（self-Encapsulation）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class A ... private B b; private double xx; double xxx1(double x1, int x2)&#123; return xx * x1 * x2; &#125; double xxx2(double x1, int x2)&#123; return xx * x1 * x2; &#125; # 将 xx 般至B里面&lt;!-- A 进行自我封装 --&gt;class A ... private B b; private double xx; double xxx1(double x1, int x2)&#123; return xx * x1 * x2; &#125; double xxx2(double x1, int x2)&#123; return xx * x1 * x2; &#125; private void setxx(double arg)&#123; xx = arg; &#125; private double getxx()&#123; return xx &#125; &lt;!-- xx 移到B --&gt;class B ... private double xx void setxx(double arg)&#123; xx = arg; &#125; double getxx()&#123; return xx; &#125; &lt;!-- 这样，就算A中有很多对xx 的引用，就只要修改--&gt; private void setxx(double arg)&#123; // xx = arg; b.setxx(arg); &#125; private double getxx()&#123; // return xx return b.getxx(); &#125; 其实自我封装，也是多加了一层。一层函数调用 提炼类，类内联化（Inline Class），一个类太大，抽象得不合理，应该提炼。内联是指一个类没有承担足够多的责任，不应该单独存在，将这个类内联到其他类中。 隐藏委托关系，移除中间人，如下，B把责任全部都委托给了C，如果A 完全不知道C 的存在，则称为隐藏委托关系。有时候抽象的目的就在于此，减少耦合。但如果B 这个中间人（Middle Man）越来越大时，干脆就直接移出中间人B，直接调用C 1# A调用 B，B再调用 C获得结果后，给 A返回 引入本地函数，或者本地扩展，当某语言的标注库函数提供的功能无法满足开发需求，可以引入本地函数，相当于java 函数重写 1234567891011121314151617# 比如微信小程序request 封装一下function request(option)&#123; // dosometing(); wx.request(option);&#125;# 调用自己写的request 函数requset(&#123; url: url, method: 'GET', success: function(res) &#123; // xxx &#125;, fail: function(err) &#123; // xxx &#125; &#125;) 重新组织数据 自封装字段， 在类里面操作字段用函数，不直接访问。是否封装，一直以来存在争议。建议先不封装，如后面不满足需求时再封装，就像将字段搬移到其他类前，先进行字段自我封装一样。 对象取代数值、对象取代数组 值对象改为引用对象、引用改为值 两个类之间的双向关联，就像双向绑定一样，在js 动态语言实现更方便，无需提前说明字段，直接添加。用过 layaAir 游戏里面，物理引擎body 和现实画面物体的坐标进行帧循环同步 配置常量代替魔法数字 封装字段，类里面的字段应该设置为private，并提供set/get 方法给外部访问。否则，字段被外部操作，类却不知道（因为直接访问字段）。这样做把数据和行为分开了。 数据类取代记录，把数据归类，抽到类中，该类没有只有数据，没有行为 类型码的取代，如 switch/case 类取代类型码 子类取代类型码 state/strategy（设计模式） 取代类型码 重新组织数据的方法，其中4、5、6、7 比较常用，5、7对数据归类，抽取配置是必须要求的。对类型码的处理，等涉及了再熟悉。 简化条件表达式 分解、合并条件表达式，比如if 成立条件判断涉及多种情况，但是为一个目的 123456789101112131415# 分解条件表达式// 是否不是夏天if(date.before(SUMMER_START) || date.after(SUMMER_END))&#123; ......&#125;// 可以抽取条件判断为一个函数，签名为 notSummer(date)# 合并条件表达式double disabilityAmount()&#123; if(xx1) return 0; if(xx2) return 0; if(xx3) return 0;&#125;// 可以合并上面判断逻辑 合并重复的条件片段，比如if/else 内都含一段逻辑，可以提取至外面 break/return 代替控制标记，结构化编程原则指明，每一个子程序只能有一个入口一个出口（单一入口原则），选择加入控制标记，降低可读性。因此编程语言提供，break/continue/return 卫语句取代嵌套条件表达式 多态取代条件表达式 引入null 对象 简化函数调用 修改函数名，可能一开始没法取一个适当的名字 添加、移除参数 将查询、修改函数分离，每个函数只做一件事 保持对象完整，将要传递的多个参数替换成一个对象，也是引入参数对象 以工厂函数代替构造函数 123456789101112131415161718192021222324252627282930313233343536373839class Employee&#123; private int _type; static final int ENGINEER = 0; static final int SALESMAN = 0; static final int MANAGER = 0; Employee(int type)&#123; _type = type; &#125;&#125;# 改为 工厂函数static Employee create(int type)&#123; return new Employee(type);&#125;# 更近一步 // 应该吧 engine/salesman/mannager 抽出成子类static Employee create(int type)&#123; switch(type)&#123; case ENGINEER: return new Engineer(); case SALESMAN: return new Salesman(); case MANAGER: return new Mannager(); default: throw new IllegalArgumentException("xx"); &#125;&#125;# 简化switchstatic Employee create(String name)&#123; try&#123; return (Employee)Class.forName(name).newInstance(); &#125;catch(Exception e)&#123; throw new IllegalArgumentException("xxx"); &#125;&#125; 封装向下转型，java 5 模板机制，模板类？ 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>改善代码</category>
        <category>重构</category>
      </categories>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[k-means]]></title>
    <url>%2F2018%2F11%2F19%2Fk-means%2F</url>
    <content type="text"><![CDATA[k-means 聚类 描述： 聚类是无监督学习，训练数据集都是未添标签的(不知类别)。就连数据集最终要分成几类都是不知道的。 和分类区别，分类的目标事先已知。 算法： 数据集1234567891011121314151617181920212223242526272829303132331.658985 4.285136-3.453687 3.4243214.838138 -1.151539-5.379713 -3.3621040.972564 2.924086-3.567919 1.5316110.450614 -3.302219-3.487105 -1.7244322.668759 1.594842-3.156485 3.1911373.165506 -3.999838-2.786837 -3.0993544.208187 2.984927-2.123337 2.9433660.704199 -0.479481............ 假设 图为： | 2.0 | .. . | . . .. 1.5 | . .. | .. . 1.0 | . . . | . . . 0.5 | .. . . | .. . . . 0.0 | . . . | . . . -0.5 | . | -1.0 |_______________________________________ -0.2 0.0 0.2 0.4 0.6 0.8 1.0 1.2 算法核心 123456789101112131415161. dataSet: 把上面数据放在 二维矩阵dataSet2. 指定 你想把 数据集分为 k 类3. 随机产生 k 个质心，A1(x1, y1)、A2(x2, y2)、.....An(xn, yn) 3.1 产生方法,选出矩阵第一列 min1, max1 选出第二列 min2，max2, 3.2 在 min1-max1 随机产生x1,在 min2-max2 产生 y1, A1(x1, y1) 4. 遍历全部数据点，离哪个质心距离最近，数据就归为那类 建立一个二维矩阵，存储各个数据 分类情况 和 误差（离质心距离） 5. 更新质心：计算每个类所有点的均值作为质心6. 重新 遍历全部数据点， isChange = false ， 若没有一个数据归类 改变，则聚类结束。 结果 12345678910111213141516结果分为4类为： |2.0 | .. . | . . ..1.5 | . + .. .. | .. . ...1.0 | . . # . . | . . .0.5 | .. . . | ..&amp;... . .0.0 | . . . | . * . -0.5 | . |-1.0 |_______________________________________ -0.2 0.0 0.2 0.4 0.6 0.8 1.0 1.2 二分K-均值算法 选择哪一个簇进行划分，能最大程度降低SSE(误差平方和)，即各点距质心最小 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>数据处理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>k-means</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回归和树回归]]></title>
    <url>%2F2018%2F11%2F17%2F%E5%9B%9E%E5%BD%92%E5%92%8C%E6%A0%91%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[预测数值型数据：回归 描述：用于回归，数据集是连续型的，用线性回归找到最佳拟合直线。 算法原理： 最小二乘法 12345678普通线性回归：最小二乘法假设拟合 方程为：y = w0 + w1x1 + w2x2 + .... + wnxn拟合值和实际值 是有误差的，使得误差最小的情况下，求出系数。防止误差的正负相互抵消，利用平方的形式求和。误差平方和，用向量的形式表达，求其最小值，在导数等于0处求得。求得相应的公式。 预测值和真实值的匹配程度，可以通过两个序列的相关系数来判断。 局部加权线性回归 给每个数据点赋予权重 读入数据并创建所需矩阵，之后创建对角权重矩阵 weights 预测鲍鱼的年龄，对比普通线性回归 和 局部线性回归 数据的特征比样本点还多的情况(输入矩阵x, xTx 无法求逆) 三种处理方法 岭回归 lasso 前向逐渐回归 权衡偏差 与 方差 关键特征：结合预测乐高玩具套装的价格说明，通过观察 岭回归 的回归系数的变化过程(循环10次)，可以得到哪个特征是关键的，当特征有上百个时，该方法十分有效！ 树回归 描述： 普通线性回归要拟合所有的样本(局部加权线性回归除外)，有些问题是非线性的，不能使用全集线性模型来拟合。 另外一种方法是，将数据集切分，然后利用线性回归技术建模，比如树回归。 算法原理： 切分数据集算法，前者决策树使用的是 ID3 算法， 按照特征的不同特征值来确定切分份数，但这样无法处理连续型数据。回归树利用CART进行二元切分，小于该特征值归为左子树，大于归为右子树。 构建回归树 数据集 1234567891011121314151617181920212223242526272829 常数项 特征x0 要预测y1.000000 0.067732 3.1765131.000000 0.427810 3.8164641.000000 0.995731 4.5500951.000000 0.738336 4.2565711.000000 0.981083 4.5608151.000000 0.526171 3.9295151.000000 0.378887 3.5261701.000000 0.033859 3.1563931.000000 0.132791 3.1103011.000000 0.138306 3.149813......假设 图为： |2.0 | .. . | . . ..1.5 | . .. | .. .1.0 | . . . | . . .0.5 | .. . . | .. . . .0.0 | . . . | . . .-0.5 | . |-1.0 |_______________________________________ -0.2 0.0 0.2 0.4 0.6 0.8 1.0 1.2 寻找最佳切分特征，特征值，chooseBestSplit() 12345678910对每个特征： 对每个特征值： 将数据切分成两份 计算误差， 如果当前误差小于最小误差，更新误差、最优特征值返回最佳切分 特征、特征值其中误差计算，采用 总方差 的形式。对于数据集， 首先计算所有数据的均值，然后计算每条数据的值到均值的差值的平方，求和。 即，为总方差。 构建回归树，递归过程 123456当交给一 个待切分 的子集给 chooseBestSlit()需要考虑各种 切分 的情况1. 如果所有 值相等则退出2. 如果切分后误差减小不大，则退出，设置停止条件 tols3. 如果切分出来的数据集很小，则退出 结果： 123456789101112131415 |2.0 | | .......1.5 | | .......1.0 | | .....0.5 | | ........0.0 | | ........-0.5 | ...... |-1.0 |_______________________________________ -0.2 0.0 0.2 0.4 0.6 0.8 1.0 1.2 叶节点(就是不在进行切分的数据集)，设置为一个常数，即，全部数据的均值。 树剪枝 描述：如果一个树的节点过多，可能是过拟合了。 预剪枝：手动修改停止条件tols 对误差的数量级敏感度 后剪枝：合并叶节点，如果合并降低误差，就将叶节点合并。 模型树 把叶节点由 常数 设置为分段线性函数 确定不再切分子集后，用普通线性回归，计算出该 回归系数 结果 123456789101112131415 |2.0 | . | . 1.5 | . | . 1.0 | . | . 0.5 | . | . 0.0 | . | .-0.5 | ..... |-1.0 |_______________________________________ -0.2 0.0 0.2 0.4 0.6 0.8 1.0 1.2 普通线性回归 VS 树回归 VS 模型树 分别计算由以上算法得来的 预测值yHat， 和目标值实际值y的 相关系数 利用 NumPy corrcoef(yHat, y) 来计算相关系数 GUI方便算法调参 利用 python包 Tkinter 创建 GUI 集成 Matplotlib 和 Tkinter 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>数据处理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>回归和树回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机森林]]></title>
    <url>%2F2018%2F11%2F15%2F%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%2F</url>
    <content type="text"><![CDATA[集成算法-随机森林 描述：分类算法，随机森林是指随机抽出一些样本集，去训练出多棵决策树，最后新数据被多棵决策树判断类别，新数据类别取多数者。随机是指对训练数据集的随机抽取，对特征的随机抽取；森林是指多棵决策树。 原理解释，结合例子：声呐信号分类 准备数据 12345样本1：0.02,0.0371,0.0428,0.0207, .....,0.0032,R样本2：0.0453,0.0523,0.0843,0.0689, ...., 0.0044,R样本3：0.0262,0.0582,0.1099,0.1083,.....,0.0078,M.....样本n: 0.026,0.0363,0.0136,0.0272,......,0.0115,M 把数据集，分成 n_folds 份样本集，采用无放回抽取。 123456dataset: [[样本1],[样本2],[样本3],[样本4], .... ,[样本n],]第1份：[[样本2],[样本5],[样本89],[样本34], ... ,[样本x1]]第2份：[[样本3],[样本51],[样本389],[样本324], ... ,[样本x2]]...第n_fols份：[[样本21],[样本45],[样本89],[样本34], ... ,[样本xn]] 交叉验证 1234567891011121314151617总样本集：[[样本集1], [样本集2],...,[样本集n_folds]]取样本集1 为测试数据，剩下的样本集为训练数据train = [[样本集2],...,[样本集n_folds]]test = [[样本集1]]整理一下：train = sum(train, [])-----&gt; 把列表里面的列表取消掉取样本集2 为测试数据，剩下的样本集为训练数据 取样本集3 为测试数据，剩下的样本集为训练数据......取样本集n_folds 为测试数据，剩下的样本集为训练数据这样就叫做交叉验证 训练决策树 1234567891011121314151617设置决策树的深度 max_depth，叶子结点数 min_size生成决策树的个数 n_trees， 选取特征的个数 n_features1. 回想生成决策树的算法 传入训练数据 train = sum(train, [])2. 从全部的数据集特征中，随机选取特征 n_features 个 决策树选取最优的特征、特征值，涉及 gini 的概念。 比如选取第一个特征，进行分子集，由于每个样本的特征值此时不同 遍历全部的特征值， 小于归左子树，大于归右子树。 获得 gini 值 最小的 最优特征、特征值。 3. max_depth, 设置树深度可以提前结束递归，建立决策树 防止过拟合4. min_size 测试测试集，交叉验证n_folds 次 声呐信号分类的结果 1234567891011121314151617设置: n_folds = 5 n_trees = 10 max_depth = 20 min_size = 1结果：决策树1 决策树2 ....... 决策树10Trees: 10五份准确率：Scores: [85.71428571428571, 83.33333333333334,80.95238095238095, 85.71428571428571, 90.47619047619048]Mean Accuracy: 85.238%random= 0.13436424411240122 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>数据处理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>随机森林</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Logistic回归]]></title>
    <url>%2F2018%2F11%2F13%2Flogistic%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[Logistic回归 描述： 分类算法，回归是对一些数据点进行拟合，该拟合过程称为回归，这样的思想是用来做预测的。为什么能用来分类呢？ 假设有一个这样的函数，f(z) = 1/(1 + e^(-z)), 显然随着z 增大 f(z)的值逼于1; 随着z的减小，f(z) = 0。 如果把自变量Z的值范围扩大到，如-20 到 20， f(z)就是一条突变的0到1的很陡曲线。 结合机器学习 数据集(含特征和类别) 12345678910111213特征1 x0 特征2 x1 类别-0.017612 14.053064 0-1.395634 4.662541 1-0.752157 6.538620 0-1.322371 7.152853 00.423363 11.054677 0假设 f(z) 的自变量 z = w0*x0 + w1*x1 (w0,w1 就是接下来要求的!)将 z 代入 f(z)，该z使得f(z)产生突变， 即可得到在0 &lt; f(z) &lt; 1 规定 f(z) &lt; 0.5, 该数据 归为第一类规定 0.5 &lt; f(z), 该数据 归为第二类求 w0, w1 就是实现这一思想核心！ 相关数学知识： 梯度 假设 z = f(x, y) 三维图像，类似一座山峰的表面图形，像一顶帽子的图像。 梯度：假设取山峰上一点 A(x0, y0, z0)，接下你想朝一个最陡峭的方向 往上爬。该最陡峭的方向即为 A 点的 梯度。 梯度求法： 12345678910z = f(x, y)a向量 = ( 函数f对x 求偏导， 函数f对y 求偏导)求在 A(x0, y0, z0) 的梯度为 将x0， y0 带入 a向量如： z = 2*x^2 + y^2a = (4x, 2y)A的 梯度为 (4x0, 2y0) 移动步长：k 123456A1 = (x0, y0) + k * a这时 沿着梯度方向a (最陡峭方向) 爬一定的长度，就到了新的一个点A1， 再按照该方法就可以 到新的点A2这样一直爬下去A3, A4.....An 就爬到了最高点An 疑问 求 w0, w1 是利用 迭代，为什么后一次迭代效果比前一次好。 每一次迭代用了梯度，但是不理解，梯度在这里的用处！ 其他书籍有的，通过损失函数的概念，来求 w0,w1 运行代码 ​ 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>数据处理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Logistic回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[朴素贝叶斯]]></title>
    <url>%2F2018%2F11%2F11%2F%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%2F</url>
    <content type="text"><![CDATA[朴素贝叶斯 描述：分类算法，一个新数据出现，是类A的概率为P(A)，属于类B概率p(B)，若p(A) &gt; p(B)，则新数据归A类，反之B类 应用：文本分类，屏蔽社区留言板的侮辱性言论 公式推导 条件概率公式 1p(x/c) = p(x,c)/p(c) 乘法公式 1p(x,c) = p(x/c)P(c) 贝叶斯公式 123p(c/x) = p(c,x)/p(x) = P(x,c)/p(x) = p(x/c)p(c)/p(x)p(c/x) = p(x/c)p(c)/p(x) 算法应用 12p(c1/w) = p(w/c1)p(c1)/p(w) 12p(c0/w) = p(w/c0)p(c0)/p(w) 123456p(c1/w) 代表 w言论出现时为侮辱性言论c1的概率，c0 代表非侮辱性判断w是c1 或者 c0 ， 实则比较 p(c1/w)，p(c0/w)大小比较等式右边，分母相同，比较 p(w/c1)p(c1)， p(w/c0)p(c0)p(w/c1)代表 侮辱性言论出现该新言论的概率，下面详细解释p(c1) 出现侮辱性言论的概率 收集数据： 123456789postingList = [[&apos;my&apos;, &apos;dog&apos;, &apos;has&apos;, &apos;flea&apos;, &apos;problems&apos;, &apos;help&apos;, &apos;please&apos;], [&apos;maybe&apos;, &apos;not&apos;, &apos;take&apos;, &apos;him&apos;, &apos;to&apos;, &apos;dog&apos;, &apos;park&apos;, &apos;stupid&apos;], [&apos;my&apos;, &apos;dalmation&apos;, &apos;is&apos;, &apos;so&apos;, &apos;cute&apos;, &apos;I&apos;, &apos;love&apos;, &apos;him&apos;], [&apos;stop&apos;, &apos;posting&apos;, &apos;stupid&apos;, &apos;worthless&apos;, &apos;garbage&apos;], [&apos;mr&apos;, &apos;licks&apos;, &apos;ate&apos;, &apos;my&apos;, &apos;steak&apos;, &apos;how&apos;, &apos;to&apos;, &apos;stop&apos;, &apos;him&apos;], [&apos;quit&apos;, &apos;buying&apos;, &apos;worthless&apos;, &apos;dog&apos;, &apos;food&apos;, &apos;stupid&apos;]]classVec = [0, 1, 0, 1, 0, 1]假设每一行是一条言论classvec 代表言论类别 准备数据： 统计全部言论，去重之后的词汇，词汇集= [‘词1’,’词2’,…,’词n’] 对每条言论，基于词汇集， 统计每个词出现次数， 未出现写0，出现+1 分类侮辱性言论、非侮辱性言论来统计，出现词数量123456789101112131415161718192021222324词汇集： [&apos;词1&apos;，&apos;词2&apos;,&apos;词3&apos;,&apos;词4&apos;,....,&apos;词n&apos;]言论1： [2, 0, 1, 9,....,4]言论2： [3, 2, 0, 0,....,2] ......言论n： [0, 2, 2, 2,....,0] 总侮辱言论：[45, 122, 232, 0,.....,90]总非侮辱言论：[123, 23, 23, 2,.....,23]侮辱性言论各个词出现概率：总侮辱言论/总侮辱言论中出现的词汇总个数n1， [45, 122, 232, 0,.....,90]/n1即下面的 [p(F1/c1)、p(F2/c1)、....p(Fn/c1)]非侮辱性言论各个词出现概率：总侮辱言论/总侮辱言论中出现的词汇总个数n0，[123, 23, 23, 2,.....,23]/n0即下面的 [p(F1/c0)、p(F2/c0)、....p(Fn/c0)]p(c1) = 总侮辱性言论数/总言论数p(c0) = 总非侮辱性言论数/总言论数言论1, 词1出现2次....p(w/c1), w言论里很多词F1、F2、F3、F4.....Fn，且这些词出现相互独立。p(w/c1) = p(F1/c1)p(F2/c1)....p(Fn/c1)p(w/c0) = p(F1/c0)p(F2/c0)....p(Fn/c0)至此，p(w/c1)p(c1), p(w/c0)p(c0)都是已知量 测试数据 防止p(Fi/c1) = 0， 词汇计数初始值1，总词汇初始值2，即[123, 23, 23, 2,…..,23]+1 / (n0+2) 防止p(Fi/c1) * p(Fj/c1)….p(Fk/c1) = 0，采用对数，即 log [123, 23, 23, 2,…..,23]+1 / (n0+2) 上面类似矩阵数乘运算 使用算法即可 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>数据处理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>朴素贝叶斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树算法]]></title>
    <url>%2F2018%2F11%2F09%2F%E5%86%B3%E7%AD%96%E6%A0%91%2F</url>
    <content type="text"><![CDATA[决策树 描述： 分类算法：一个未贴标签(未知类别)的新数据(含多个特征)，通过问多个问题（问题是：特征，答案：是或者否），最终问题问完，判断出新数据类别。问问题的流程基于决策树。 应用：判断生物是否鱼 收集数据： 分析数据：使用任何方法，构造树完成之后，我们可以将树画出来。 123456789101112131415特征1（不浮出水面是否能活） 特征2（是否有脚蹼） 类别(是否鱼) yes yes yes yes yes yes yes no no no yes no no yes no变成向量的形式： dataSet = [[1, 1, &apos;yes&apos;], [1, 1, &apos;yes&apos;], [1, 0, &apos;no&apos;], [0, 1, &apos;no&apos;], [0, 1, &apos;no&apos;]]labels = [&apos;no surfacing&apos;, &apos;flippers&apos;]labels 存储的是特征，即决策树的问题 准备数据 计算给定数据集的香农熵的函数 假设我们在特征1和特征2选特征1来分类，即问一个问题(此新数据不浮出能活吗)，安照答案(即特征值yes no )得到分类，并计算该数据集的香农商(用于衡量此数据集混乱程度) 1234567891011121314151617181920 1, 1, &apos;yes&apos; 0, &apos;no&apos; 1, &apos;yes&apos; 1, 1, &apos;yes&apos; 1, &apos;yes&apos; 1, 0, &apos;no&apos; ----------&gt; 0, 1, &apos;no&apos; 1, &apos;no&apos; 1, &apos;no&apos; 0, 1, &apos;no&apos; 由特征1分类，子集去掉特征1，计算数据集香农熵分类前香农熵： - 2/5log(2/5) - 3/5(log3/5) 分类后香农熵： - 3/5*(2/3log(2/3)+1/3log(2/3)) - 2/5*(1log1)对数底为2香农熵越小，数据越有序分类前香农熵：2/5 yes 占全部类别的2/5, 3/5 同理分类后香农熵：3/5 表示该子集占全集，2/3表示 yes在子集占比若子集类别一致，香农熵为 0公式如下： 1H = - p(x1)log p(x1) - p(x2)log p(x2) - ...... 选择最好的数据集划分方式 当前划分数据集应采用哪个特征呢？（问哪个问题呢？） 全部特征集合labels存储，逐一尝试，计算分类前后香农熵，选取信息增益(熵差)最大的特征x， 划分后的子集去除特征x, 集合labels去除特征x 递归，递归终止条件应理解，构造决策树 返回 {&#39;no surfacing&#39;: {0: &#39;no&#39;, 1: {&#39;flippers&#39;: {0: &#39;no&#39;, 1: &#39;yes&#39;}}}}，画出决策树123456789 不浮出水面是否能活 / \0 / \ 1 / \ no 是否有脚蹼 / \ 0 / \ 1 / \ no yes 测试决策树 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>数据处理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K-近邻算法]]></title>
    <url>%2F2018%2F11%2F07%2FK-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[K-近邻算法 描述：用于分类，先有已知类别的数据集，输入一个样本，利用K-近邻算法得出该样本的类别， 一个样本包括特征、类别等数据 原理： 带有标签(类别)样本数据集，包含样本特征 输入没有标签的新数据，将新数据和样本集数据对应的特征进行比较 计算新数据和样本集的欧式距离 取出最小的前k个 取出这k个样本中出现次数最多的类别，作为新数据的类别标签 应用：优化约会网站的配对效果 数据样本包括:前三个是特征，最后一个是类别1234567飞行常客历程数 玩游戏占时间比 每周冰淇淋消费 类别 40920 8.326976 0.953952 3 14488 7.153469 1.673904 2 26052 1.441871 0.805124 1 .....其中类别 1不喜欢的人 2魅力一般的人 3极具魅力的人最终输入新数据，用 K-近邻 判断其类别 过程： 收集数据：提供上面格式的文本数据 准备数据：python解析文本，返回一个矩阵A包含样本集特征，一个类别矩阵B 分析数据：Matplotlib画二维散点图，剔除一些点 训练数据：此步骤不适合K-近邻算法，和测试工作一样 测试算法：取数据集(已知类别)一些点，测试是否分类正确，否，标记一个错误 使用算法：产生简单命令行程序，输入一个新数据特征，输出其类别 注意： 一个样本相当矩阵A的一行，计算距离可以先把各个特征(A的各个列)归一化，如线性函数转换、对数函数、反余切函数转换 K 的取值 算法的函数封装好了，不用自己实现 应用在手写数字识别，数字是32*32 矩阵，先将转成一行(一行代表一个样本) 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>数据处理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>K-近邻</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习介绍]]></title>
    <url>%2F2018%2F11%2F05%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[入门机器学习 作用：机器学习是一门人工智能学科，是用数据或以往的经验，以此优化计算机程序的性能标准。 应用：数据挖掘、计算机视觉、自然语言处理、搜索引擎、证券市场分析、语音识别、战略游戏等 学习场景 模式识别：很古老，过时。环境与客体统称为“模式” 机器学习：给计算机输入一些数据(采集)，学习数据（学习步骤明确），获得新技能。 深度学习：是机器学习新领域，模拟人脑进行分析学习的神经网络，解释数据（图像、声音、文本）。 机器学习基础 微积分、统计学/概率论、线性代数 python 语言 机器学习主要任务 分类：将实例数据划分类别，二分类(如，邮件是否为垃圾邮箱)，多分类(手写数字自动识别) 回归：预测数值型数据(股票价格预测，房屋价格预测) 聚类：在无监督学习中，将数据集分成由类似的对象组成多个类的过程称为聚类。 密度计算：通过样本分布的紧密程度，来估计与分组的相似性。 学习类型（后面深入理解再补充） 监督学习 必须确定目标变量的值，以便机器学习算法可以发现特征和目标变量之间的关系。在监督学习中，给定一组数据，我们知道正确的输出结果应该是什么样子，并且知道在输入和输出之间有着一个特定的关系。 (包括：分类和回归) 非监督学习 在机器学习，无监督学习的问题是，在未加标签的数据中，试图找到隐藏的结构。因为提供给学习者的实例是未标记的，因此没有错误或报酬信号来评估潜在的解决方案。 非监督学习包括的类型：聚类、密度估计 强化学习 训练决策：程序在某一情况下尝试所有的可能行动，记录不同行动的结果并试着找出最好的一次尝试来做决定。如，马尔可夫决策类型 算法 监督学习(分类)： k-近邻算法 决策树 朴素贝叶斯 Logistic回归 支持向量机 集成方法-随机深林和Adaboost 监督学习(回归)： 预测数值型数据 树回归 非监督学习 K-means聚类 机器学习开发流程 收集数据：收集样本数据 准备数据：注意数据的格式 分析数据：为了确保数据集中没有垃圾数据 选定、训练算法[算法核心]：监督或者无监督 测试算法[算法核心]：评估算法效果 使用算法：将机器学习算法转为应用程序 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>数据处理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目合作总结]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[回想自己和其他开发人员团队合作中，有过各种各样的问题。比如 哪些明明是简单的需求，却要花很多时间，还不能保证稳定。 平时花费很多时间去学习，看似很努力却得不到想要的回报 需求变得越来越难写 开发的效率没有提高，还是用以前一贯的思路 后来发现这是自己没有好的工作习惯，因此总结了一下，引起重视 工作原则 敬畏之心，每个人应该对项目的规范怀有敬畏之心，否则不仅不能因为合作提高效率，还会引发更多麻烦。比如遵循git flow 流程，发布项目必须经历内网、外测、正式服，还有其他一系列团队约定的开发规范。 分清需求优先级，分清需求的轻重缓急，就不会弄得自己手忙脚乱。 空杯心态，团队合作免不了交流沟通，如理解需求、约定代码结构等，我们应保存空杯心态，平静表达自己的观点，谦虚听取大家的意见，最终做合理的决定。比如 要在其他同事基础之上添加需求，但他的设计不合理或者不满足 感觉产品需求不合理，或者无法实现 改善代码，当发现需求越来越难以实现，想添加新需求却感到困难，不妨试试重构现有代码。当然你必须学习重构技术 p/pc 平衡 ，一个养鸡的农夫不给鸡喂食就得不到更多的鸡蛋，杀鸡取卵更是连得到鸡蛋的资本都失去了。产出和产能必须平衡提示我们 想提高效率，要持续关注新技术，改善思路 必须坚持锻炼，保持开发人员健康身体 怎样接触新技术结合自己学习经历和接触到的有经验开发者，谈谈自己是怎样学习新技术的。比如你接触小程序 官方文档术语规范、内容齐全，看完都得花一段时间，不宜入门。可以看优秀的入门文章（但其他时候还是不怎么建议，xx入门除外），比如这篇没有html/css 基础的小程序入门 结合实际、总结、细看官方文档，可以和其他语言进行对比 持续关注小程序社区，解决遇到的难题 解决状态管理、跨页通信问题 编写css 花费大量时间 比如，你想入门less 看官方文档挺费劲，先看入门文章大概就清楚了 再结合实战，细学 更深入的，抓住框架设计原理，学会画架构图、流程图、类图、思维导图，有助自己尽快抓住技术核心。别总是停留在语言语法应用层面，语言用来完成业务的语法或有不同。没有必要那么在意，这个只是设计者的习惯。学东西，最忌一直零散，浮于表面，那就是一直依赖搜索解决问题的搬运工。 分析设计原理的优劣，培养技术选型能力， 实现一个业务问题，分析技术解决方案的优劣，设计是否符合扩展性（完善代码，设计模式） 推动团队在团队开发中，一开始可能不知道那里阻碍了你，哪个部分你的效率还可以提高。但是可以列出花费时间最多的环节，并想办法优化，就这样持续迭代。比如小程序开发中（按时间多少排序） css 编写页面 沟通：联调后端API，理解需求 设计代码结构，实现 这时我就会查找利用less 提高编写效率，利用 postman/mock 等联调工具，去社区寻找别人的解决方案。 其他效率工具总结了一些提高工作效率的工具，有些是来自同事分享 命令行启动软件，把软件启动的快捷方式复制至同一目录，并添加至环境变量，在不用碰鼠标，不用切换当前窗口的情况下按win+R，通过输入软件名称（当然可以自定义）启动应用。 查找软件 everything，可以搜索计算机所有盘符，进行查找，秒速 截图软件 Snipaste，所截图位于窗口最上方，实现代码对比，达到分屏效果 打开搜索 Wox，不用切换窗口进行搜索，按Alt+ space –&gt; g xxxx，如在编辑器页面迅速调动搜索 便签，计划提醒 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>工作总结</category>
        <category>效率</category>
      </categories>
      <tags>
        <tag>工作原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware 安装centos6.5 虚拟机]]></title>
    <url>%2F2018%2F10%2F20%2Fvmware%20%E5%AE%89%E8%A3%85centos%20%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[在本地安装虚拟机，并用secureCRT 连接可以搭建测试环境，提高开发效率。 安装在vmware 安装centos6.5， 可以选择最小化安装，这种模式好像没有鼠标，但是可以利用vmware 完成粘贴复制，连接好secureCRT后就没影响了。安装了desktop 版本，也可以删除桌面。 vmware centos6.5 bin DVD1 secureCRT 连接安装 secureCRT，提取码：q9wb，设置好自己习惯的操作方式，如选中复制，右键粘贴，背景色等。连接 生成私秘钥，Tools–&gt;Create Public Key –&gt; key type: RSA —&gt; OpenSSH Key format centos 生成私秘钥文件 12# root 用户，/root/.ssh 下生成ssh-keygen -t rsa 公钥复制到 /root/.ssh/authorized_keys 文件中，必须是这个文件名 centos 查看ip 地址 1234567891011121314151617# 设置网卡随系统启动生效cd /etc/sysconfig/network-scriptsls //查看网卡文件 如ifcfg-eth0vim ifcfg-eth0 //修改为 ONBOOT=yes# 必须 root用户， 重启网卡service network restart# 是否生效ping www.baidu.com // 没问题# 查看网卡 ip ifconfig // 如，inet addr:192.168.36.100# 该ip, 和主机是同一个子网内，# 在cmd 命令行 ipconfig 查看到 VMware Network Adapter VMnet1# 因为vmware 默认配置一个网卡ANT 连接方式，没有的话，可能是在网络共享中心--&gt; 更改适配器设置 禁用了 连接，File–&gt; Quick Connect ，把publicKey 放到第一位置，连接成功 对网络概念不熟悉可以，参考理解 配置静态ip上面虚拟机的ip 下次开机可能会发生改变，比如你在vmware 再建立一台虚拟机发现ip 变了。这种情况可以把 ip配置成静态ip vmware 给该虚拟配置网卡（默认就是一张网卡NAT 方式，也可以） VMware –&gt;编辑–&gt;虚拟网络编辑器–&gt; NAT –&gt; 取消dhcp 动态分配 VMware –&gt;编辑–&gt;虚拟网络编辑器–&gt; NAT –&gt; NAT 设置，查看网关 配置centos /etc/sysconfig/network-scripts/ifxxx 网卡 12345678910111213# device 和网卡名一样# 添加最后5 项就可以了，改成你虚拟机相应ipDEVICE=eth0HWADDR=00:0C:29:32:46:15TYPE=EthernetONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticIPADDR=192.168.36.100NETMASK=255.255.255.0GATEWAY=192.168.36.2DNS1=192.168.36.2 # 和网关一样 root 重启 网卡服务, service network restart ifconfig 查看是否为自己设置的ip 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>基础</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vmware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序 自定义组件]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[小程序中如果一个页面UI太过复杂，亦或者某个UI组件复用次数多，可以考虑抽取出自定组件。抽离组件可以 分而治之，使代码结构更清晰，也是重构的目的。 复用，使逻辑出现在唯一出 自定义组件页面中的网络头像有加载过程，可以在加载过程中给图像一个占位图。而这复用率很高，可以考虑抽取组件 头像图片未加载成功之前显示占位图，利用bindload方法 123456789101112131415161718192021&lt;!--profile.wxml--&gt;&lt;view class='v-h-center'&gt; &lt;image class="&#123;&#123;isFinishLoad ?'':'before-load'&#125;&#125;" src='&#123;&#123;imgSrc&#125;&#125;' bindload='finishLoad' /&gt; &lt;/view&gt;&lt;!--profile.js--&gt;finishLoad: function()&#123; this.setData(&#123; isFinishLoad: true &#125;);&#125;&lt;!--profile.wxss--&gt;.before-load &#123; width: 64rpx; height: 64rpx; border-radius: 50%; border: 1rpx solid #a7a7a7; background-color: #EEE;&#125; 点击头象，通知触发父组件事件 1234567// 引用组件的页面.wxml&lt;profile bindXXX='xxx' imgSrc='&#123;&#123;xxx&#125;&#125;' data-xx="&#123;&#123;xxx&#125;&#125;" /&gt;&lt;!--profile.js--&gt;_event: function(e)&#123; this.triggerEvent('XXX') &#125; 相册授权小程序中将图片或者视频，下载后保存到用户本地相册需要用户授权。若用户首次拒绝授权，再次下载时，得再次弹出询问授权按钮，否则图片无法下载。 保存到相册，首次拒绝授权，第二次保存失败，再次询问 wx.openSetting1234567891011121314151617181920212223242526272829wx.saveVideoToPhotosAlbum(&#123; filePath: res.tempFilePath, success: res =&gt; &#123; this.showMsg('视频已保存到相册~~'); &#125;, fail: res =&gt; &#123; this.getPhotoAuthorize(); &#125;&#125;);getPhotoAuthorize: function () &#123; wx.showModal(&#123; title: '提示', confirmText: '去授权', content: '授权后才能保存到相册噢', success: res =&gt; &#123; if (res.confirm) &#123; console.log('用户点击授权') wx.openSetting(&#123; success: function (res) &#123; if (!res.authSetting["scope.writePhotosAlbum"]) &#123; console.log('重新授权成功') &#125; &#125; &#125;) &#125; &#125; &#125;)&#125; 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>前端</category>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>自定义组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 入门]]></title>
    <url>%2F2018%2F10%2F16%2Flinux%20%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[linux 是后端项目运行的环境，很多开发者都是在windows 下编写代码，后部署到linux 上运行。所以linux 是很重要的基础，是开发人员需要了解的。学习资料参考 建议用centos—下载 bin-DVD1 鸟哥私房菜第三版 安装可参考 linux 起源 Unix、GUN、Linux起源， 追求：先求有且能运行，再求进一步改善 linux 的版本是指内核版本。linux 版本分为两类，一种使用RPM 方式安装软件系统，包括Red Hat、Fedora、SuSE、CentOS; 另外一种 dpkg 方式安装软件，包括 Debian、Ubuntu、B2D linux 多用户、多任务，与Windows系统不同。文件的属性可分为可读，可写，可执行，属性可分为文件拥有者、文件所属用户组、其他非拥有者与用户组者。 缺点，没有特定的支持厂商，游戏支持度不够、专业软件的支持度不够（如：绘图软件） 文件权限 linux 是多人多任务的， 用户的配置信息在etc/xx 下面。进入文件夹要x 权限，r 只能查看文件夹的文件列表 linux 下面全部都是文件，文件没有后缀，也有一些常见的 .sh、 .tar.gz 只是为了启动见名知义 linux 各个目录存放的规范 安装软件一般放在，usr/local 或者 opt 目录规范和操作 查看 环境变量，相对、绝对目录 echo PATH 执行当前目录的命令时，加入./ 目录与文件常用命令 touch/mkdir cat vim mv cp/cp -r scp rm -rf xx rm -rf xx/* 目录、文件权限，umask, 可以通过umask 提前设定要创建目录的权限值，文件默认权限 666，目录默认权限 777 12345umask umask -Sumask 022 // 022 的值解释# 022 代表0 相对默认权限减去 0 + 0 + 0 权限# 2 代表减去 0 + 2 + 0 写权限没有了 修改用户权限—chmod/chown/chgrp 添加用户、组、other 文件的查找 which 在当前环境变量下路径查找 whereis 寻找特定文件，速度快 find 硬盘查找，速度慢 文件的压缩与打包压缩，文件用0，1 存储后还有很多空间未填满或者有很多重复数据，将这些空间填满或者减少空间就是压缩技术的目的。 比如数字1，由于 1byte = 8bits，其他7bits 默认为0，第一位为1 比如重复有100 个1, 并不需要真正存储100个1，标记100个1，减少空间 linux 的命令只能压缩一个文件，所以先把文件打包在进行压缩。最常用打包、压缩命令： 压缩：gzip -v 文件名 12345-c ：将压缩的数据输出到萤幕上，可透过数据流重导向来处理；-d ：解压缩的参数；-t ：可以用来检验一个压缩档的一致性～看看文件有无错误；-v ：可以显示出原文件/压缩文件的压缩比等资讯；-# ：压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！默认是 -6 打包：tar 123tar -zcv -f filename.tar.gz 要被压缩的文件或目录名称tar -zxv -f filename.tar.gz -C 想解压到的目录tar -ztv -f filename.tar.gz 查看文件 tar.gz 先打包再压缩的文件 linux 正确的关机方法1234567# 机器状态 谁在线who # 关机，重启shutdown -h now // 时间参数务必加，否则跳到单人维护的登入情况reboot sync //把内存数据写到硬盘，上面两个命令包含了这个 安装软件在linux 下安装软件是必须掌握的技能，安装方式一般有yum install，直接安装rmp包，编译安装源码包等方式。 yum install 原理，yum install 安装rpm 软件包 123456789101112131415161718192021222324252627282930# 列出可用的 rpm 包yum list | grep 包名yum rearch 包名# 安装yum install [y] xx // 回答所有的问题 yes# 删除yum remove xx# yum 其他常用命令ls /etc/yum.repos.d //yum 仓库的配置文件&lt;!-- 比如卸载桌面 --&gt;yum grouplist | grep Desktopyum groupremove -y Desktop// 修改 /etc/inittab 里面的 为3，不是5 (x11)# Default runlevel. The runlevels used are:# 0 - halt (Do NOT set initdefault to this)# 1 - Single user mode# 2 - Multiuser, without NFS (The same as 3, if you do not have networking)# 3 - Full multiuser mode# 4 - unused# 5 - X11# 6 - reboot (Do NOT set initdefault to this)# id:3:initdefault: 直接安装 rpm 包 123456789101112131415161718# 查询是否安装rpm -q 包名 # 安装rpm -ivh 包文件# 卸载rpm -e 包名# 查询 rpm包，a--all q--queryrpm -aq | grep rpm # rpm 其他常用命令rpm -Uvh 包名 // 包升级rpm -qi 包名 // 查询指定包信息rpm -ql 包名 // 列出包安装文件rpm -qf 文件绝对路径 //查看该文件由那个包安装 源码编译安装，比如 centos 安装 git 工具，源码下载 1234567891011121314151617181920# 解压 .tar.xz 或者 .tar.gztar -Jxvf git-2.9.5.xz -C .# 源码安装 先配置安装目录，有助后期卸载、迁移./configure prefix=/usr/local/git-2.9.5# 编译 make# 安装 一般两个命令一起写 make &amp;&amp; make install make install # 一般再设置一个git 软连接，安装软件的习惯ln -s git-2.9.5 git # 添加环境变量vim /etc/profileexport PATH=/usr/local/git/bin:$PATHsource /etc/profile 文本处理技巧在linux 编辑文本是很常见的操作，比如修改配置文件、查看项目日志、处理文件数据、编写shell script 等等，这些都要用文本处理。 编写文本一般用vim 编辑器 查看文本内容的几种方法 12345678910111213# 打印文件所有内cat filename 容# 跟踪打印输出文件tailf xx.log# 打印文件最后10行的数据tail -n 10 # 打印文件第10行开始以后的内容tail -n +10 # 打印前10的内容head -n 10 grep 用于文本内容的查找，文本三剑客之一，常配合管道使用 12345ls -lh xx | grep xxps aux | grep mysqlnetstat -tlnp | grep redis sed 用于文本内容的编辑，常用于文本替换 12345678910111213141516# sed [option] 'command' filename# option-n：使用安静(silent)模式。 在一般sed的用法中，所有来自stdin的数据一般都会被列出到终端上。 但如果加上-n参数后，则只有经过sed特殊处理的那一行(或者动作)才会被列出来。-e：直接在命令列模式上进行sed的动作编辑。-i：直接修改读取的文件内容，而不是输出到终端。直接修改真实文本# commanda：追加，a的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)i：插入，i的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)d：以行为单位的删除c：以行为单位的替换，c的后面可以接字串s：在行中搜寻并替换p：以行为单位的显示，通常p会与参数sed -n一起运行 awk 用于对文本进行分析，当要对处理的数据生成报告，或者数据是按照列进行处理时，使用awk 更方便 12345# 输出第一列 awk '&#123;print $0&#125;' demo.txt# 用冒号分割每行文本 awk -F ':' '&#123; print $1 &#125;' demo.txt 数据流重定向 1234567891011121314151617181920# 将ls -l 输出的信息重定向到 /data/tmp/rootfilels -l &gt; /data/tmp/rootfile# 追加ls-l &gt;&gt; /data/tmp/rootfile# cat 创建文件cat &gt; catfile xxxx按ctrl+d 离开# 输入 eof 结束cat &gt; catfile &lt;&lt; 'eof'xxxxeof # 用文件代替手动输入cat &gt; catfile &lt; filename 查看进程和端口号 ps aux 查看运行程序 12345678910111213# a 不与 terminal 有关的所有 process # u 有效使用者 (effective user) 相关的 process # x 通常与 a 这个参数一起使用，可列出较完整资讯。ps aux# USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.0 19232 1508 ? Ss 18:55 0:03 /sbin/init# user process 属于的用户 # PID 识别码# %CPU 使用的CPU 资源占比# %MEM 内存百分比 netstat -tlnp 网络联机状态1234567891011# -a ：将目前系统上所有的连线、监听、Socket 数据都列出来# -t ：列出 tcp 网络封包的数据# -u ：列出 udp 网络封包的数据# -n ：不以程序的服务名称，以埠号 (port number) 来显示；# -l ：列出目前正在网络监听 (listen) 的服务；# -p ：列出该网络服务的程序 PID netstat -tlnp# Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 1996/nginx linux 启动流程理解linux启动时都做什么可以完成一些设置 比如完成 卸载桌面 123456789101112131415&lt;!-- 比如下载桌面 --&gt;yum grouplist | grep Desktopyum groupremove -y Desktop// 修改 /etc/inittab 里面的 为3，不是5 (x11)，如下：# Default runlevel. The runlevels used are:# 0 - halt (Do NOT set initdefault to this)# 1 - Single user mode# 2 - Multiuser, without NFS (The same as 3, if you do not have networking)# 3 - Full multiuser mode# 4 - unused# 5 - X11# 6 - reboot (Do NOT set initdefault to this)# id:3:initdefault: 设置服务在开机时自启动 12345# 在 /etc/rc.d/rc.local 添加 /etc/init.d/mysql start/etc/init.d/redis start/etc/init.d/php7-fpm start 同步网络时间1234567891011# 安装ntpdate工具yum -y install ntp ntpdate# 设置系统时间与网络时间同步ntpdate cn.pool.ntp.org# 将系统时间写入硬件时间hwclock --systohc# 开机启动校对 也可以写到crontab 定时同步网络时间echo &quot;ntpdate -u ntp.api.bz &amp;&amp; clock -w&quot; &gt;&gt; /etc/profile 用户群主概念、账号管理 UID/GID，比如用户 lcs，在/etc/passwd 里面对应 lcs—UID 500 12345678910lcs:x:500:500:lcs:/home/lcs:/bin/bash&lt;!--各个字段含义：--&gt;1. lcs 名词2. x 口令，但是未显示，存在/etc/shadow3. 500 UID 0代表root，1-499 系统账号4. 500 GID5. lcs 用户信息说明栏6. /home/lcs 家目录 7. /bin/bash 给用户一个shell（bash） 和系统沟通 /etc/shadow 存放各用户密码 lcs 用户一登入就有一个初始群组lcs，lcs用户可以加入其它群组，加入这么多群组，创建新文件属于的群组是有效群组。 1234567891011&lt;!--组名和GID 对应--&gt;etc/grouproot:x:0:root1. root 群组名2. x 口令，未显示3. 0 GID4. root 该群组包含的用户，把lcs 加入会显示 root,lcs&lt;!--查看所属群组，第一个为有效群组，新文件所属群组--&gt;groups 可以切换lcs 用户的有效群组，涉及/etc/gshadow 扩充linux 根目录下面链接都可以完成扩容，计算机里面一个磁盘显示的是 /dev/sda，两个显示/dev/sdb，利用 fdisk对磁盘进行分区。理解 pv/vg/lv 对完成扩容有帮助 扩容–详细 扩容–简略 pv/vg/lv 概念理解123456/dev/sda1/dev/sda2 ...&lt;!-- 删除未知lv --&gt;vgreduce --removemissing [vgName]vgreduce --help 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>基础</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序笔记]]></title>
    <url>%2F2018%2F10%2F16%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近接触了一段时间小程序，记录了在开发过程中的一些结论 小程序开发 小程序前后端交互过程 wx.login()获得code，传给后台服务器 后台服务器请微信服务器请求，返回openId/sessionKey（用于获取用户已授权的其他数据，如运动步数），后台把openId/sessionKey存储在session，前端header里就会得到一个set-cookie 小程序前端要缓存（setStorageSync），每次请求携带cookie，后台就可以判断是哪个用户，这个过程要自己实现（和浏览器不一样） 用户授权过程 授权窗口按确定1234567&lt;button open-type=&apos;getUserInfo&apos; bindgetuserinfo=&quot;getUserInfo&quot;&gt; &lt;text&gt;微信授权&lt;/text&gt;&lt;/button&gt;getUserInfo: function(res) &#123; xxxx&#125; 改变小程序每个页面或者单页面的背景色 在app或者xx.wxss 加入，page 前面不用点123page &#123; background-color: #f4f4f4;&#125; wx：key 在渲染中的作用 当指定wx:key时，列表改变时（包括内容和顺序），渲染时只是重新排序各组件，而不用重新创建 key 要求唯一 key 对性能提高有好处 小程序异步问题，首页onLoad() 抢在app.js 的login 方法之前执行 封装代码方法，函数回调12345678910111213141516171819function waitFlag(signalOrigin, flag, status) &#123; return new Promise(function(resolve, reject) &#123; let i = 0 let check = function() &#123; if (!!signalOrigin[flag] === !!status) &#123; resolve() &#125; else if (i++ &gt; 1000) &#123; reject() &#125; else &#123; setTimeout(check, 50) &#125; &#125; check() &#125;)&#125;waitFlag.waitFlag(app.globalData, 'hasGet', true).then(() =&gt; &#123; xxxxxx&#125;) 轮播图，图片，高度自适应(提前知道图片的WH，赋值给swiper) 图片设置为 懒加载，否则加载过多图片手机迅速发烫 点击图片放大功能 视频图像得先下载，再保存到相册 给图片添加水印，或者二维码（建议后端来做：一条linux命令搞定） cavans 画图，加字 cavans 利用绝对定位隐藏，画图是visable: true visable: false，导出图片到相册 ios 下video 出问题，无法部分视频 设置 video 的custom-cache=”false“ e.currentTarget.dataset/e.Target.dataset 的区别 图片加载时的占位图 视频不在可视范围，停止播放12345678910111213ready() &#123; // 在自定义组件内，一定要加上后面参数 this this.videoContext = wx.createVideoContext('swiperVideo', this) if (this.videoContext) &#123; this.createIntersectionObserver().relativeToViewport(&#123; top: -100, bottom: -100 &#125;).observe('.swiper-video', (res) =&gt; &#123; this.videoContext.pause(); &#125;); &#125;&#125; 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>前端</category>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 深拷贝问题]]></title>
    <url>%2F2018%2F10%2F08%2Fjs%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[js 深拷贝js 里面很多东西都是对象，很容易出现引用问题。引用相同的对象多次，且修改时特别注意js 的深拷贝问题， 下面是我写的错误代码一部分， 123456789101112131415161718pId = &#123; 12: [&#123;xx:'7', ...&#125;], 21: [&#123;xx:'6', ...&#125;], 31: [&#123;xx:'7', ...&#125;] &#125; starInfos = &#123; 6: [], 7: [] &#125; let Activities = [] for (let pId in posts) &#123; let Activity = starInfos[posts[pId][0].xx])); Activity.like = posts[pId][0].like; Activities.push(Activity);&#125;; Activity 实际上是多次引用了starInfos.7，并且对他进行修改，导致Activities 第1/3 元素相同，修改如下： 1let Activity = JSON.parse(JSON.stringify(starInfos[posts[pId][0].xx])))); js 修改对象下面是我遇到修改对象的情况， 修改js 对象，合并对象 修改对象 123456let a = 'gender';let b = &#123; name: 'lcs'&#125;b[a] = 'boy' 利用 Object.assign(target, source1, source2) 12345678910111213aa = &#123; name: 'lcs'&#125;bb = &#123; gender: 'boy'&#125;Object.assign(aa, bb);aa = &#123; name: 'lcs', gender: 'boy'&#125; promisepromise 只关心自身逻辑，不关心结果处理。没有promise 你必须把网络请求success/fail 处理函数写在请求里面，反之，你可以把处理程序写在.then/.catch里面。这样把网络请求和处理请求结果的逻辑分开，使代码结构更清晰。比如， 模拟请求代码，下面是一个向服务端发起请求的函数 1234567891011121314function test(resolve, reject) &#123; var timeOut = Math.random() * 2; log('set timeout to: ' + timeOut + ' seconds.'); setTimeout(function () &#123; if (timeOut &lt; 1) &#123; log('请求成功...'); resolve('200 OK'); &#125; else &#123; log('请求失败...'); reject('timeout in ' + timeOut + ' seconds.'); &#125; &#125;, timeOut * 1000);&#125; 处理请求结果的逻辑，可以和请求函数分开 1234567var p1 = new Promise(test);var p2 = p1.then(function (result) &#123; console.log('成功：' + result);&#125;);var p3 = p2.catch(function (reason) &#123; console.log('失败：' + reason);&#125;); 注意的是， 下面代码返回的是，带有网络请求结果的promise 对象 123return new Promise(function(resolve, reject)&#123; xxx&#125;); new promise().then() 会返回一个promise 对象，return 和 resolve 差不多一样效果，resovle 是执行成功的返回结果。 12345678910111213141516171819let a = return http.post(`/api/refresh.php`, data, true).then(res =&gt; &#123; return res.data; &#125;)a.then(res =&gt;&#123; // res 就是上面的res.data&#125;)&lt;!--若改为--&gt;let a = return http.post(`/api/refresh.php`, data, true).then(res =&gt; &#123; return new Promise(function(resolve, reject)&#123; resolve('lcs') &#125;); &#125;) a.then(res =&gt; &#123; // res 还是一个Promise 对象&#125;) 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>深拷贝</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css 应用总结]]></title>
    <url>%2F2018%2F09%2F29%2Fcss%20%E5%BA%94%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[css伪类下面是自己使用过 伪类的几种场景 :last-child利用 css:last-child，实现循环四个元素，每一个元素都有底边框，但最后一个元素没有 注意 xx:last-child 找到有共同父节点样式为xx 的元素 再选定最后一个元素，该元素必须处在最后一位，且不能有其他不相关元素 比如复杂一点的形式：12345678910111213141516&lt;view&gt; &lt;view class="xx"&gt; &lt;text&gt;tt&lt;/text&gt; &lt;view class='yy'&gt;bb&lt;/view&gt; &lt;/view&gt; &lt;view class="xx"&gt; &lt;text&gt;tt&lt;/text&gt; &lt;view class='yy'&gt;bb&lt;/view&gt; &lt;/view&gt; &lt;view class="xx"&gt; &lt;text&gt;tt&lt;/text&gt; &lt;view class='yy'&gt;bb&lt;/view&gt; &lt;/view&gt;&lt;view&gt; css 代码应该这样写，12345678.xx .yy &#123; border: 1rpx solid #a7a7a7; border-width: 0 0 1rpx 0;&#125;.xx:last-child .yy &#123; border-width: 0;&#125; :nth-child(3n+2)利用 :nth-child(3n+2) 实现一个九宫格，用于展示图片。实现效果如下， 页面利用flex 布局，标签代码12345678&lt;view class='activities'&gt; &lt;view wx:for='&#123;&#123;starActivity&#125;&#125;' wx:key='postId' class='activity'&gt; &lt;image class='img-activity' src='xx' mode='aspectFill'&gt;&lt;/image&gt; &lt;xx&gt;&lt;/xx&gt; &lt;xx&gt;&lt;/xx&gt; &lt;/view&gt; &lt;/view&gt; 12345678910111213141516171819202122232425.activities &#123; width: 750rpx; padding: 30rpx; display: flex; flex-wrap: wrap; box-sizing: border-box;&#125;.activity &#123; width: 32%; height: 226rpx; margin-bottom: 15rpx; border: 1rpx solid #eee; box-sizing: border-box;&#125;.activity:nth-child(3n+2)&#123; margin-left: 15rpx; margin-right: 15rpx;&#125;.activity .img-activity&#123; width: 100%; height: 100%;&#125; 注意，img-activity 宽高设置为 100%，是指子元素 内容宽高==父元素 内容宽高，至于内容宽高指什么，是由box-sizing 值确定的（默认值 content-box)。 box-sizing: border-box 设置的width/height == 内容宽高 + padding + border box-sizing: content-box 设置的width/height == 内容宽高 在这里 activity 的内容宽高 = wh - (padding + border)， 所以img wh = 226rpx - 1rpx css 动画很多时候页面要添加动画，优化用户体验，可以利用css 语法支持实现。css 动画，不是瞬间变动，而是有个缓动效果，实现效果 实现效果，需要在点击后给元素添加一个样式修饰，下次点击又重现效果，类似 xx:hover。微信小程序元素（view/button）的 hover-class 刚好支持。实现如下123456789101112131415161718&lt;view class="action-sort-mount" hover-class='scale'&gt; &lt;image class="user-like img-WH" src="&#123;&#123;isLike?'/images/like_on.svg':'/images/like.svg'&#125;&#125;" /&gt; &lt;text class='text1'&gt;&#123;&#123;xx&#125;&#125;&lt;/text&gt;&lt;/view&gt;.scale &#123; animation: 0.3s myScale;&#125;@keyframes myScale &#123; from &#123; transform: scale(0.5, 0.5); &#125; to &#123; transform: scale(1, 1); &#125;&#125; transform: translate(x, y)利用 transform: translate(x, y) 实现一张 图片在底下一张图片（宽高未知）居中的效果， 步骤如下，12345678910111213141516171819202122232425&lt;view class='video-one-poster-icon'&gt; &lt;image class='video-one-activity' src='&#123;&#123;xx&#125;&#125;' mode="aspectFill"/&gt; &lt;view class='bg'&gt;&lt;/view&gt; &lt;image class='video-icon' src='/images/video-icon.svg' /&gt;&lt;/view&gt;.bg&#123; width: 100%; height: 100%; position: absolute; left: 0; top: 0; background: #000; opacity: 0.3;&#125;.video-icon&#123; width: 100rpx; height: 100rpx; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);&#125; 善于利用 transform 改变元素大小，移动位置。 css 加边框利用css 给元素加上边框，可以利用下面两种方式实现 border 属性，设定边框宽度，假设要实现上下边框 12border: 1rpx solid rgba(0, 0, 0, 0.15);border-width: 0rpx 0rpx 1rpx 0rpx; 设置 box-shadow ， 阴影矩形会往上下移动 1rpx 123456/* x偏移量 | y偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 */&lt;!-- 这个元素阴影盒子的偏移，正负含义类似 定位的left/top--&gt;box-shadow: 0rpx -1rpx 0rpx 0rpx rgba(0, 0, 0, 0.15);&lt;!-- 把阴影延y 轴下移1rpx --&gt;box-shadow: 0px 1px 0px 0px rgba(0, 0, 0, 0.15) css 加蒙版 滤镜、透明度实现给元素加一层 蒙版12345&lt;!-- 透明度 --&gt;opacity: 0.7&lt;!-- 滤镜--&gt;filter: grayscale(50%) 这就是一些关于学习css 的体会，欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>伪类</tag>
        <tag>动画</tag>
        <tag>边框</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 学习笔记（二）]]></title>
    <url>%2F2018%2F09%2F29%2Fvue%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[接触了 vue基本语法之后，应该进一步学习vue 对页面的组件化编程 组件化页面可以实践一下 vue-router+koa+mysql 的项目，建议可以先学习下面内容 动态组件 单页面应用 SPA vue-router 使用 Vue.js 组件化前端开发新思路，阅读完这个会加深对vue 的认识 node.js 访问mysql 自动化工具熟悉以上技术，你可以使用一些自动化工具来构建项目了，就像git flow 的脚本工具一样。 vue-cli 入门，vue-cli 官方文档 webpack 了解 组件间通信 vuex 还可以了解 用vue.js 封装的element ui 框架，Admin-UI 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 学习笔记（一）]]></title>
    <url>%2F2018%2F09%2F27%2Fvue%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[vue.js 是实现双向绑定mvvm 的框架，用它写项目可以实现前后端分离。起初误以为它是类似easyUI/bootstrap这样的前端UI框架，接触之后发现并不是，它是为了使得页面组件化。 Vue 起步首先学习Vue 官方文档，看到组件基础那边。感受一下它的双向绑定，加上之前接触了es6 就不会觉得vue 语法那么奇怪。vue 一些笔记 mvvm，一旦 vue实例里面的 data改变，会重新渲染一遍页面 当需对后端返回数据做处理再show时，利用计算属性、侦听属性来实现 既然能动态绑定数据，那标签的class 自然也可以 vue.js 渲染页面时，常见的情况 条件渲染 列表渲染（for 里面有个恶心的key） 事件处理（点击，按键，鼠标），注意事件修饰符，就是事件函数本身有些问题要处理，如事件只能点击一次，事件截流…，但是这个和业务逻辑没有关系，不能把处理程序写在事件函数里面，通过事件修饰符来实现 12345&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt; 常常需要获取用户操作页面上的很多控件如input/textarea/checkbox/radio/option的结果, 利用vue 的v-model 指令 组件 在组件上的一些自定义事件实现，涉及input 的v-model 组件的slot 插槽语法，微信小程序自定义组件就是利用了slot 动态组件，vue组件实现tab 更换显示不同的组件 写vue+koa的项目可以写一个简单项目来体会一下vue 的语法，需要涉及下面知识点 module.exports，当js 代码越写越多的时候能不能像java 一样利用import 来分模块引入，js 利用函数式编程和闭包特性来实现这一想法。 js 模块实现–by 廖雪峰 axios，对前端向服务器发起请求的代码进行封装 Promise 理解 axios 使用 npm，这是js 的包管理工具，类似java maven。只要在项目的package.json 文件中配置依赖，输入命令就会自动下载。 npm 入门–菜鸟 npm 常用命令 npm package.json字段说明 koa，是基于node.js 的web框架，对http进行了封装。可以用它来处理前端发来的请求。 koa 入门 遇到的问题结合以上技术vue+koa，简单的实现了blog 首页。效果如下图，勿喷，代码在这里 实现过程中遇到一些问题 命令node app.js 实例化koa对象可以监听端口，为什么跳转不到static/index.html 页面上 加载静态资源，用/index.html 即可访问，不用前缀static12const serve = require(&apos;koa-static&apos;);const main = serve(path.join(__dirname, &apos;static&apos;)); 如何返回json 字符串 “mount” 和 mount 是一样的，把js对象转成字符串 json 原本就是字符串123456789var content_sort = async (ctx, next) =&gt; &#123; ctx.response.type = &apos;json&apos;; let data = [ &#123; mount: 3, sort: &quot;日志&quot; &#125;, &#123; mount: 5, sort: &apos;分类&apos; &#125;, &#123; mount: 3, sort: &apos;标签&apos; &#125; ]; ctx.response.body = JSON.stringify(data);&#125;; 为什么前端用v-for 渲染后，会生成html 标签，但是看不到 html 没有标签；微信小程序有，我靠。改为span12345678910111213141516171819202122&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt; &lt;div v-for=&quot;sort of sorts&quot; :key=&quot;sort.id&quot;&gt; &lt;text&gt;&#123;&#123;sort.mount&#125;&#125;&lt;/text&gt; &lt;text&gt;&#123;&#123;sort.sort&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: &apos;#app&apos;, data: &#123; sorts: [ &#123; mount: 3, sort: &quot;日志&quot; &#125;, &#123; mount: 5, sort: &apos;分类&apos; &#125;, &#123; mount: 3, sort: &apos;标签&apos; &#125; ] &#125; &#125;);&lt;/script&gt; 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 一些笔记（一）]]></title>
    <url>%2F2018%2F09%2F26%2Fjs%20%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[在学习js 开发前后端的过程中，感觉刷新了自己的认知。很多以为只有其他语言才能完成的功能，js 却也实现了，虽然封装的过程不一样。真的慢慢意识到语言是工具。 js 一些笔记学习js 语法，和其他接触过的语言对比一下 js es6增加了map/set 数据结构，遍历对象有for–of 和 forEach方法 js和java 不同，可以解构传参 c++/java 里面的对象，一定得先定义class，并且class里面要有属性，方法等。但是js定义对象，类似json vue 页面的Vue对象就种写法 微信小程序的page 对象也是这种写法 java是静态的，js是动态的。可以动态给对象添加属性和函数，甚至给内置的函数重新指向新函数。 动态指定属性, 假如你想实现一个简单的对象双向指向 1234567var a = ['a', 'b', 'c'];a.name = 'lcs';var b = ['d', 'e']a.objectB = b;b.objectA = a; 你想实现函数的重载，用于调试或者比如，简单统计一下该函数调用次数, parseInt 是window对象的方法 12345678910111213var count = 0;var oldParseInt = parseInt;window.parseInt = function()&#123; count += 1; return oldParseInt.apply(null, arguments);&#125;;//testparseInt('10');parseInt('10');console.log('xx', count); //2 js的函数式编程(return 函数或者函数为参数)，使得对象里面的this指向变得复杂起来；java没有函数式编程，没有this 的指向问题 返回函数 或者函数内再定义函数，这两种情况都很容易引发this坑 var that = this/apply 箭头函数(常用)，this和词法作用域绑定，即外层调用者123456789101112var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = () =&gt; &#123; new Date().getFullYear() - this.birth; // this指向obj对象 &#125; return fn(); &#125;&#125;;obj.getAge(); // 25 js和python 一样有高阶函数，对数据处理起来更方便 map在Array 里面，对Array每一个元素做同样处理，但一般需求是不同处理 reduce，感觉不常用，可用来求和 filter, 过滤Array 元素, return true 保留，否则删除 1234567var a = ['a', 'b', 'c'];a.filter(function(element, index, self)&#123; // element a b c // index 0 1 2 // slef Array本身 a return true // 保留，false删除&#125;) sort 默认把Aarry 元素转换为string 再比较大小 高阶函数，函数传入函数123456789101112131415var a = [&#123; age: 12, ts:'12121232' &#125;,&#123; age: 132, ts:'32121232' &#125;,&#123; age: 132, ts:'121231232' &#125;]a.sort(function(a, b)&#123; return 1 // b a 返回正值，不管你搞什么，我只认正负 return 0 // b=a return -1 // a b 返回负值&#125;) js 闭包功能 函数fun1里面可以再定义一个函数fun2，若fun2使用了fun1的变量，通过调用fun1返回fun2，以后延迟再fun2()，变量没有出问题了。这就是闭包 闭包的功能，返回一个函数然后延迟执行 js/python 的生成器功能类似 面向对象编程，js 除了用{ }来定义对象外，也可以用new 关键字来实现。但是在es6之前不像c++/java 语言定义对象有class 关键字，定义对象和对象的继承都必须要求正确实现原型链，继承是原型链的继承。 创建对象 为了实现创建多个对象，共用一个hello函数，在原型链上做调整 1234567891011121314151617181920212223function Student(name) &#123; this.name = name; this.hello = function () &#123; alert('Hello, ' + this.name + '!'); &#125;&#125;var xiaoming = new Student('小明');var xiaohong = new Student('小红');xiaoming.name; // '小明'xiaohong.name; // '小红'xiaoming.hello; // function: Student.hello()xiaohong.hello; // function: Student.hello()xiaoming.hello === xiaohong.hello; // false//调整原型链function Student(name) &#123; this.name = name;&#125;Student.prototype.hello = function () &#123; alert('Hello, ' + this.name + '!');&#125;; 继承，没有class 关键字，思路是在原型上实现继承，代码量大 es6 Class 继承，对原型继承实现了封装，es6封装了原型1234567891011121314151617181920212223class Student &#123; constructor(name) &#123; this.name = name; &#125; hello() &#123; alert('Hello, ' + this.name + '!'); &#125;&#125;var xiaoming = new Student('小明');xiaoming.hello();class PrimaryStudent extends Student &#123; constructor(name, grade) &#123; super(name); // 记得用super调用父类的构造方法! this.grade = grade; &#125; myGrade() &#123; alert('I am at grade ' + this.grade); &#125;&#125; 参考文章 js教程–by 廖雪峰 es6教程–by 阮一峰 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html/css 写页面]]></title>
    <url>%2F2018%2F09%2F25%2Fhtml%2Bcss%2F</url>
    <content type="text"><![CDATA[用html/css 怎样写出页面呢，看到每个页面都有很多html标签和css 修饰属性，难免会被吓到。其实我们只要从整体到细节，即页面结构到元素来理解页面是如何组合在一起的，就可以入门。 页面是如何组合在一起的首先页面是由html 标签组成的，每个标签都代表一个盒子（如下图），盒子有外边距、边框、内边距、内容宽高等属性。 标签之间可以嵌套 display，决定标签是否独占一行，或者由自身宽高决定所占位置 position，标签在页面位置原本是从上到下排列，但可以改变 比如，下面代码12345678910111213141516&lt;div class='border-show'&gt; div &lt;/div&gt;&lt;div class='border-show'&gt; div &lt;/div&gt;&lt;span class='border-show'&gt;span&lt;/span&gt;&lt;span class='border-show'&gt;span&lt;/span&gt;&lt;style&gt; .border-show &#123; border: 1px solid #000; margin: 50px; padding: 1px; &#125;&lt;/style&gt; 效果如下， display 属性规定元素应该生成的框的类型，明显div 该属性值为block，span 是inline（这是默认值）。可以通过修改display 来改变div 框的类型，常用属性值如，block/inline-block/flex。常用的块级元素有div p form ul ol li等，行内元素span strong等。 position 属性指定一个元素（静态的，相对的，绝对或固定）的定位方法的类型，常用的有： static，默认值，就是按照从上到下的顺序排列页面元素 fixed，指该元素，脱离原本的从上到下的顺序，只以浏览器窗口为参照物，通过 left/top/right/bottom 来控制和浏览器的相对位置。stickly 类似 relative，指该元素，相对从上到下的原本位置进行移动，通过left/top/right/bottom 来控制。注意，元素相对定位移动之后，原来所占位置不会消失。 absolute，指该元素，相对于第一个含（position：除static 外）的父元素进行移动 left/top/right/bottom 的正负值含义如下图 用什么布局写页面利用静态、相对、固定的定位方法，加上flex 弹性布局就可以用html/css 写出页面 学习flex 弹性布局可以参照flex 布局语法篇–by 阮一峰 学完语法之后，强烈建议动手实现骰子的布局，你会发现刚刚的理解并不是这么准确 接下来也可以用flex 布局去实现常用的页面布局，如栅格系统、圣杯布局、垂直居中等 整体到细节理解了页面的布局，就应该去熟悉一下css 在页面元素细节地方是怎样控制的。比如css 选择器、css伪类、css3的新特性 css 系统了解 css 属性参考手册 mozilla.org 我用html+css 简单实现了一下blog 的首页面，效果如下图，勿喷。这是源码 这就是一些关于html/css 写页面的体会，欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入门建议]]></title>
    <url>%2F2018%2F09%2F20%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%BB%BA%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[接触了前端，下面记录自己对前端的一点体会。记得大学时候是很害怕写页面的，总被大量标签和css 吓得无从下手，现在看来是由于当初不懂得如何学习新技术，没有给自己定制合适的step by step 入门学习。希望学习前端能开拓自己视野，对技术认识更深一层。 前端入门 Html+css 页面结构，上色(10%)，两周时间差不多就能熟悉。 js(90%)，得花大量的时间。 需要编程思维 简单的框架应用，jQuery + bootstrap，简单逻辑，动画 es6 –&gt; vue(中小company)，react(大company)，angular(国内较少) 完成1 2，可工作，根据熟练程度可达初中级前端工程师的水平。 学习js 需要慢慢积累打好基础，就不难。第一次看觉得懵逼，第二次能理解一些，第三第四次慢慢的明白是怎么回事，这种感觉就对了。 通过上面3步的学习，实现功能是没有问题的。但是没法优化，一般实现方式有 前端方式，比如缓存，压缩，离线存储，加载延迟等。 非前端方式，比如Vue里面 css/js合成一个很大的文件，加载页面有一段空白时间，利用前端方式是没法优化，的需要后端渲染。这是时候要去学习 node.js 前端做什么 偏向设计 html + css + js ps 绘画功底 实现UI设计图 html+ css+ js基础 ps vue/react/angular 会其中一个 npm 包管理工具 游戏，H5/微信小游戏（作业能力必须很强） html + css + 原生js一定要强 Cocos2d.js web storage webGL websocket 偏向后端的前端，全栈–&gt;node工程师 h + c + j node.js mysql monogDB/redis 集群cluster pc前端，类似 钉钉 NW.js 移动端的前端，手机，不想同时开发Android ios App h+C+j 框架 node npm 手机兼容性，屏幕适配（必考必问） 调试chrome 微信小程序 学习方式 查在线资料，看文章或者在线视频，比如麦子学院/极客学院/慕课/极客时间。参考里面的学习步骤，给自己规划适合的step by step 入门实践（很重要） 自学，找一个会的人监督你学习（很重要） 安排任务 解决问题 js基础太差别着急用框架，就算是通过面试，对框架很依赖，也用不好 学习周期别拉太长，写代码写到安心再去睡觉，哈哈 初级–&gt;中级的一些瓶颈 代码质量太差 变量命名 文件目录 代码冗余，只是实现功能 扩展性太差 逻辑不清晰 测着，测着就通了，不想再看自己的代码 定位问题慢 在思维上意识到了阻碍自己进步的地方，会有一种豁然开朗的感觉，但想要有所进步还是得靠实践，可以从下面几点做起： 优化代码，成长更快 优雅代码的养成 可扩展性，1个是1个类型，2个是2个类型，&gt;2就是1个类型 模块化 阅读源码 京东/天猫/携程的页面源码，js/css分开，腾讯不建议（命名奇怪） github上引入插件–使用插件–修改插件 阅读自己曾经嫌弃的框架，bootstrap(透明规范)/jQuery 我觉得在中级会遇到的瓶颈和改善方式不仅适合前端，在其他技术方向也是一样的。中级到高级离自己有距离，不太懂。但从接触的同事建议说， 别框架追星，业务合适才最重要 开阔视野 这就是一些关于学习前端的体会，欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python datetime模块]]></title>
    <url>%2F2018%2F09%2F16%2Fpython_module_time%2F</url>
    <content type="text"><![CDATA[当大家用到时间属性去分析数据时，难免会对时间做各种的转化；步骤虽然不难，代码一 google也能得到。但如果不明白其中原理，每次搜索得到的代码会比较繁杂。 而且我希望自己写代码能够，思路越来越明朗，代码量越来越少，速度越来越快！因此想总结一下python datetime模块对时间的常用操作。 time 一些概念编程时常遇到一些时间的概念如，epoch/UTC(GMT)/时间戳，这是人们为了把时间表达清楚而下的定义。你想精准把一个时间表示成秒数，需要 基准时间，就是从哪个时间起呢？ 时区 我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，UTC代表的是0时区（UTC+0:00也代表0时区），北京时间在东八区（UTC+8:00）。所以 时间戳表示的就是0时区的现在时间距epoch的秒数 时间戳规定在0时区进行计算，这样就有 123timestamp = 0 = 1970-1-1 00:00:00 UTC+0:00timestamp = 0 = 1970-1-1 08:00:00 UTC+8:00 已知时间戳，马上就已知UTC+0:00，再转其他时区 本地当前时间转时间戳 获取操作系统设定的时区 转成UTC+0:00 计算距epoch 的毫秒数 把时间戳转日期 也要先获取时区，再由UTC转过来 datetime里面封装了time/date 模块，很多时候内部指定了时区 datetime 常用操作 获取日期 今天日期，先获取datetime类型，再转格式化字符串!12345678from datetime import datetimedatetime.now() out: datetime.datetime(2018, 9, 18, 20, 20, 7, 433321)datetime.now().strftime(&apos;%Y-%m-%d %H:%M:%S&apos;)out: &apos;2018-09-18 20:24:40&apos; 获取时间戳 今天日期时间戳: 先获取今天日期datetime 类型，再转时间戳 12datetime.now().timestamp()out： 1537273614.038577 把日期转时间戳: 把日期转datetime类型，再转时间戳 123456datetime.strptime(&apos;2018-09-18 20:24:40&apos;, &apos;%Y-%m-%d %H:%M:%S&apos;)out: datetime.datetime(2018, 9, 18, 20, 24, 40)datetime.strptime(&apos;2018-09-18 20:24:40&apos;, &apos;%Y-%m-%d %H:%M:%S&apos;).timestamp()out：1537273480.0 时间戳转日期 有时间戳了，datetime提供了方法转成本地时间 12345datetime.fromtimestamp(1537273480.0)out: datetime.datetime(2018, 9, 18, 20, 24, 40)datetime.fromtimestamp(1537273480.0).strftime(&apos;%Y-%m-%d %H:%M:%S&apos;)out: &apos;2018-09-18 20:24:40&apos; 时间戳转成 UTC时间 12345datetime.utcfromtimestamp(1537273480.0)out: datetime.datetime(2018, 9, 18, 12, 24, 40)datetime.utcfromtimestamp(1537273480.0).strftime(&apos;%Y-%m-%d %H:%M:%S&apos;)out: &apos;2018-09-18 12:24:40&apos; 时间差 已知一个时间，差距天数，求另外一个日期 123from datetime import timedeltadatetime.now() + timedelta(days=1)out：datetime.datetime(2018, 9, 19, 21, 2, 9, 887597) datetime.now() + timedelta(days=1)out： datetime.datetime(2018, 9, 17, 21, 2, 23, 40349) 1- 两个时间差的天数：datetime相减即可 a = datetime.fromtimestamp(1537273480.0)b = datetime.now() (b-a).days(b-a).seconds out: 0out: 1929 123#### mysql 常用命令1. mysql 一些常用命令 - 时间戳转时间 select from_unixtime(1534995065);out: 2018-08-23 11:31:05 1- 字符串转时间 select str_to_date(‘2016-01-02’, ‘%Y-%m-%d %H’);out: 2016-01-02 00:00:00 1- 时间转时间戳 select unix_timestamp(now()); out：1452001082`参考文章 datetime — Basic date and time types 这就是一些关于时间的常用操作，欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>数据处理</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>datetime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git flow入门]]></title>
    <url>%2F2018%2F09%2F16%2Fgit%20flow%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[git 是分布式项目版本管理工具，git flow 是一个优秀的git 分支模型，用来解决多人合作开发遇到的问题，让代码管理有一个清晰的流程和规范。 git flow下面文章能让你入门git flow，加上动手实践，相信你很快就能熟悉。 Git 在团队中的最佳实践–如何正确使用Git Flow 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>基础</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 常用操作]]></title>
    <url>%2F2018%2F09%2F09%2Fgit_common_operation%2F</url>
    <content type="text"><![CDATA[Git是流行的分布式项目版本管理系统，利用git flow这个优秀的分支模型可以实现多人合作开发项目；在 githbu上也可以学习其他优秀项目！在这里结合自己使用习惯，总结一下git的常用操作。但以下步骤仅涉及个人开发，并未介绍git flow多人合作。想详细了解git的开发人员可以参考 廖雪峰git教程 git安装一般是先 下载git客户端，安装好之后在电脑桌面点击右键，能看到Git Bash Here就说明安装成功！在本地利用 git初始化项目，然后再 push到你的 github上。接下来模拟一下这一过程， 在桌面新建文件夹 project 进入 project，点击右键在此目录下进入 git bash 123456789# 设置该git user$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com# 初始化git init# 此时 project内有隐藏文件 .git管理，查看ls -a 编辑文件 12# 创建 1.txt 加入一段文字，也可以采用 vimtouch 1.txt 利用 git status查看项目文件状态，可以显示哪些新增文件，删除文件，或者各个区内的文件状态！ git各区概念git正是利用工作区、暂存区、版本区这三个区来实现分布式管理项目。利用这三个区结合 github就可以实现去中心化，因为每一个开发人员的本地都会有一份项目开发过程的log备份，就算 github挂掉了，只要拿到任何一个开发人员的一份备份也可以还原分布式开发！ 工作区，就是在 project目录下看到的文件，git bash编辑命令 ls -ll 即可看到工作区的文件！ 暂存区，就是 git add [文件名]到的目录区，当需提交的文件量多，可以利用 git add .添加全部文件，同时包括删除操作！执行 add命令，还是显示红色字体，即未添加成功。可能因为某个文件夹内含另外一个被 git管理的目录，删除该目录下隐藏的git 文件即可! 123456# 在 project内利用 `git status`看文件状态# 显示**红色**提示，说明 1.txt未提交到暂存区git add 1.txt# 此时 1.txt已提交到暂存区，查看暂存区目录文件git ls-files 版本区，将暂存区的文件提交到版本区内，git status 显示的蓝色提示，就是说明添加到暂存区的文件未被提交到版本区，commit至版本区。每次 push就是将版本区的文件提交至 github 1git commit -m &apos;[本次提交的注释]&apos; push项目到 github当文件成功commit到版本区之后，git status显示 nothing to commit，接下来将项目 push到github。 在 githbu上注册账号，创建一个仓库 设置提交的远程库，采用 https 协议，origin只是一个名字可以改变 12345# 采用https协议，不要配置公私钥，但每次要输密码git remote add origin https://github.com/lcs1234567/project.git# -u 下次执行git push 就会默认push origingit push -u origin master 亦可以采用ssh协议，因为ssh协议，要配置设备私公钥至github，待私公钥生成，打开存放目录，将公钥复制，添加到你的github，点击头像/setting/SSH and GPG keys，将项目 push到 github。第一次利用ssh push是会提示 authenticity can’t be established，输入yes，回车就可以了！ 123456# 生成设备私公钥, git bash中输入以下命令，一路按回车键ssh-keygen -t rsagit remote add origin git@github.com:lcs1234567/project.gitgit push origin master 在本地git bash可以查看配置好的远程仓库 1git remote -v git 常用命令1234567891011121314151617181920212223242526272829303132333435# 设置 本机git user$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com"# https 协议 和 SSH 协议连接 github 区别# 删除git 本地分支$ git branch -d &lt;branch_name&gt;# 删除github 远程分支$ git push --delete &lt;remote_name&gt; &lt;branch_name&gt;# 本地 创建并切换到该分支 git checkout -b develop# 拉取远程分支，并且切换到该分支（原先本地没该分支）git checkout -b &lt;branch_name&gt; &lt;remote_name&gt;/&lt;branch_name&gt;git checkout -b develop origin/develop或者git checkout -t origin/develop# 查看远程分支git branch -a# 在某个分支上回归版本git log // 查看历史 commitIdgit log --pretty=oneline // 查看当前所在commitIdgit reset --hard &lt;commitId&gt; 这就是一些常用的git 管理项目的流程，欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>基础</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 搭建自己的blog]]></title>
    <url>%2F2018%2F08%2F18%2Fbuild_hexo_blog%2F</url>
    <content type="text"><![CDATA[不喜欢新浪、csdn、知乎，简书的博客平台，因为页面有广告，就用hexo框架配合github 搭建了一个自己的blog。希望将自己学习的技术经历总结下来，沉淀自己，也借此和大家一起分享、探讨。 hexo 搭建博客技能需要 了解 git 常用命令和概念 了解 linux 常用命令 安装准备博客页面是先用 md 语法编辑成为文，再由node.js 生成静态html而来，最后部署到github供大家访问。所以需在本地安装 Node.js Git 发布文章参考hexo的官方中文文档，相信你一定能够顺利完成部署之前的任务，本地博文的编辑。一般我的做法是， 利用md 编辑器把博文编辑好 参考官方文档md 文件的书写格式 在博文开头设置 title/data/categories/tags相关属性，如：12345678910title: hexo 搭建自己的blogdate: 2018/8/18categories:- 基础- blogtags:- hexo- gitcomments: true--- 把md 文件copy 至博客根目录的source/_post目录下 在博客根目录打开Git 命令行 hexo g hexo server 在浏览器通过 http://localhost:4000/ 访问博客 若你想删除博文 hexo clean 进入 source/_post 删除该md 文件 通过浏览器访问本地博文，修改至感觉满意之后，可以部署到github 供其他开发人员访问。一般步骤： 在你的github 建立仓库 仓库名，[github username].github.io 如：lcs1234567.github.io 编辑 本地博客根目录下的_config.yml 设置url: https://[github username].github.io 在文件最后添加 deploy 信息， 注意空格。如：1234deploy: type: git repo: git@github.com:lcs1234567/lcs1234567.github.io.git branch: master 由于部署项目到github 用的是ssh协议，非https，需配置私公钥 随便那个目录 打开git 命令行 ssh-keygen -t rsa 一路回车键，待私公钥生成，打开存放目录 将公钥复制，添加到你的github，点击头像/setting/SSH and GPG keys 执行部署命令，本地git命令行 1hexo d 此时可以通过 https://[github username].github.io 访问你的博客！ 设置Next 主题设置博客的主题，我当前选择next，参考 next 文档-中文。这种美化页面的细活，自己耐心做就行了。 实现 多台电脑协作如果你在家用自己的电脑编辑好博文，并通过hexo g -d部署到github；后面你又想在公司写博客、部署，但发现github所存并非源代码，而是生成后的静态文件。 解决这个问题，我一般是在github建立两个分支，打开你的[github username].github.io仓库，当前分支是master，但这是生成后的静态文件。这是因为你在_config.yml里配置了master，每次你hexo g -d 就会将静态文件部署到该分支，以后无需操心。 创建另外一个分支： 在本地博客根目录 打开git 命令行 把本地博客source commit 到版本区 1234567git init git add -Agit status git commit -m &apos;blog files&apos;git remote add hexo git@github.com:lcs1234567/lcs1234567.github.io.gitgit push -u hexo hexo 设置 hexo 为默认分支 点击博客仓库下的setting/Branches 设置默认分支为 hexo 这样以后就默认 clone 该分支，clone下来后，再进入blog根目录 npm install安装依赖 注意，git add -A 时可能目录themes/next 无法被add，这是因为next目录是你clone下来的主题，被另外一个.git/ 管理。我采用简单粗暴方法是在next/ 打开 git bash12ls -arm -rf .git/ 在公司设备 git clone 博客仓库，hexo g -d前再次生成私公钥，因为私公钥是相对设备的，设备换了必须添加该设备的公钥。 添加评论功能评论功能可选择gitalk/valine/来必力，我集成的是valine。 在valine 注册一个应用，查看app id, app key 修改 themes/next 的主题配置文件_config.yml 12345678910valine: enable: true appid: [your app id] appkey: [your app key] notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 参考文章 hexo 官方文档 next 主题配置官方文档 集成 valine评论功能 添加博客主题其他样式 设置博客首页摘要 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>基础</category>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
</search>
