<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[过滤垃圾评论]]></title>
    <url>%2F2019%2F04%2F12%2F%E8%BF%87%E6%BB%A4%E5%9E%83%E5%9C%BE%E8%AF%84%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[我们想搭建一个关于游戏的推荐系统，给用户推荐有趣、好玩的游戏。起初在还没有用户的情况下一般采用基于内容推荐，然而要还原游戏的真实面貌，清洗垃圾评论是必不可少的。下面讲讲我们在这其中的一系列尝试，处理代码戳这里 预处理我们先从渠道应用宝里面获取了很多游戏的数据，其中包括评论、用户评分。这些评论有内容简短、重复出现等特点。因此我们先进行了预处理 处理评论内容html 反转义内容、繁体转简体、去除标点符号 并选出长度大于5 的评论 去除重复三次以上的评论 接下来我们手动标记了1000条评论数据（这个样本有点少，至少要10000条的），0代表无用评论，1代表普通评论。分类模型选用了逻辑回归方法，但是如何表达样本数据使其适用分类模型是重要考虑得。我们尝试了四种表示方法 词袋模型，就是基于样本预料集的词频矩阵，各样本维度相同，元素是对应词的词频 tf-idf，利用tf-idf 优化词袋模型，只用认为是样本关键词来表示样本，而不是全部词汇 word2vec，用向量表示每个词汇，求出样本全部词汇的平均值向量表示该样本 端到端方式，利用卷积神经网络CNN学习语法特征 词袋模型词袋模型就是用词汇出现的次数来表示每个词，忽略了词汇在句子中出现的顺序，只关心词出现的次数。要求先得到全部样本的语料集，再求出每个样本基于语料集的词频矩阵。 用词袋模型表示样本之后，可视化数据观察类别分布是否明显。语料的维度很大要利用PCA特征降维技术把数据降到2个维度。 可以看到分类效果并不明显。接下来看看分类模型的效果怎么样。12345678from sklearn.linear_model import LogisticRegression# 逻辑回归 分类器clf = LogisticRegression(C=30.0, class_weight=&apos;balanced&apos;, solver=&apos;newton-cg&apos;, multi_class=&apos;multinomial&apos;, n_jobs=-1, random_state=40);clf.fit(X_train_counts, y_train);y_predicted_counts = clf.predict(X_test_counts);y_predicted_counts; 结合混淆矩阵来检验模型 1accuracy = 0.886, precision = 0.888, recall = 0.886, f1 = 0.887 我们还可以把逻辑回归模型系数的大小看成词汇的权重，系数越大代表词的权重越大。选择影响分类权重最大的词汇，看是否和实际情况相符。1234567891011121314151617181920212223&#123;&apos;bottom&apos;: [ (-1.9233468753654832, &apos;想玩过&apos;), (-1.9699934849413354, &apos;东西&apos;), (-1.9936101307589726, &apos;一科&apos;), (-2.0586707932196653, &apos;完整版&apos;), (-2.2143741219571784, &apos;第六感&apos;), (-2.2944339277405317, &apos;平台&apos;), (-2.296290346516122, &apos;张立根&apos;), (-2.5400863161740292, &apos;全过&apos;), (-2.6306392117308213, &apos;f2&apos;), (-3.1548797624472003, &apos;cnm&apos;)], &apos;tops&apos;: [ (2.1516471108530144, &apos;lajibamxigyegei&apos;), (2.1803090306315083, &apos;界面&apos;), (2.211154149794893, &apos;根本&apos;), (2.2950592487795909, &apos;下载&apos;), (2.507806444700754, &apos;广告&apos;), (2.513095684570573, &apos;不错&apos;), (2.8654346669109865, &apos;好难&apos;), (2.9219171750081423, &apos;样儿&apos;), (3.092310924958777, &apos;老是&apos;), (3.2120104179278735, &apos;不能&apos;) ]&#125; tf-idf词频逆文档（tf-idf）是找出样本关键词的一种算法，它认为出现频率最高的词就是样本关键词，为了排除那些常用词比如我、的、也的干扰，还必须是在其他样本出现频率较低的词。据此可得$tf-idf$的表达式，词汇$w$在样本出现频率$n$，样本总词汇$N$，样本总数$D$，包含$w$的样本总数$D_{in}$，$$tf-idf={n \over N} \log_2{D \over (1 + D_{in})}$$ tf-idf 对词袋模型的优化之后，分类模型的准确率有少量改善。详见源码。从效果来看感觉词袋模型不太适合短评论。 word2vec用上面词频表示词汇的方法很容易遇到语料中缺省的词，这样模型就没法进行分类。Word2Vec 是一种为每个单词生成词向量的技术。通过阅读大量文本，它能够学到并记住那些倾向于在相似语境中出现的词汇。经过足够多的数据训练，词汇表中的每个单词都会生成一个300维的向量，由意思相近的单词组成。 我使用word2vec表示词汇，要先训练自己的语料库。用向量表示每个词汇，求出样本全部词汇向量的平均值表示该样本。还是用PCA降维技术可视化到界面观察类别分布情况。 可以看到类别区分更加明显，分类器分类效果也有改善。 CNN前面介绍了快速高效地获得句子嵌入的方法，然而由于省略词汇的顺序，我们也忽略了句子中所有的语法信息。CNN 能够考虑单词的顺序，能很好地学习到句子中哪些单词的序列特征影响到目标预测。处理代码戳这里 效果如下， 参考文献 8个步骤，上手解决90%的 NLP 问题 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>数据处理</category>
        <category>提取数据特征</category>
      </categories>
      <tags>
        <tag>过滤垃圾评论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web 安全]]></title>
    <url>%2F2019%2F03%2F15%2Fweb%20%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[web 安全一直是个话题，常见的包括防范crsf攻击、sql注入，对存储在服务器的敏感数据如用户信息进行加密处理；防止程序攻网络资源，使用验证码进行识别；对于垃圾信息，敏感信息进行过滤在存储等。 csrf 防范前段时间在laravel框架下写了一个上传excel的功能，请求被认为是csrf攻击被拦截了。于是就花时间了解什么是csrf(跨站请求伪造)，对crsf不太清楚的同学可以戳这里。 laravel框架对前端的每一次请求都会返回一个cookie，key为XSRF-TOKEN，接下来的请求要在头部携带前一次返回的cookie 才能通过csrf 验证。123456789101112131415# 前端实现&lt;el-uploadref='upload'action="/xx/addData":headers="headers":limit="1":show-file-list="false":on-progress="xx":on-success="xx":on-error="xx":accept="uploadAccept"&gt; &lt;el-tooltip class="item" effect="dark" content="只能上传csv/xlsx且不超过2G" placement="top"&gt; &lt;el-button size="small" type="primary"&gt;上传&lt;/el-button&gt; &lt;/el-tooltip&gt;&lt;/el-upload&gt; 这个上传excel文件应用element ui组件，被认为是csrf攻击是未在请求头部携带相应的cookie，由于其他请求是通过axios发起的，内部会自动实现，所以能通过安全认证。可以这样解决12345678910111213headers: &#123;'X-XSRF-TOKEN': this.getCookie('XSRF-TOKEN')&#125;# 获取本地的cookiegetCookie(name) &#123; let cookiesList = document.cookie.split(';'); for (let cookie of cookiesList) &#123; let arr = cookie.split('='); if (arr[0] === name) &#123; return decodeURIComponent(arr[1]); &#125; &#125; return '';&#125; 因为开发者不能获取其他域名下的cookie，这样是可以防范csrf的 api 认证很多时候我们发送请求都是b2s，就是客户端给服务端发送请求，但有时也需要在后端请求另外一个服即s2s。比如利用php guzzlehttp/guzzle http客户端，这必定涉及api 验证。这里我用的方式是 双方先约定加密key 值，请求方携带参数、对参数加密的sign 接收方对参数重新加密一次，再对比sign，检查参数是否被篡改 在php 中是这样实现的，12345678910111213# 利用 hash_hmac sha256 算法，返回 params 加密后 的sign 字符串private function makeSign($params = [])&#123; ksort($params); $str = ''; foreach ($params as $k =&gt; $v) &#123; if(!is_null($v)) &#123; $str .= '#' . $k . '|' . $v; &#125; &#125; // appkey 是加密时用的key return hash_hmac("sha256", $str, $this-&gt;appkey);&#125; 小程序开发请求微信服务端api，也是要先获取请求的调用凭证 accessToken，获取这个凭证需要提供该小程序的appid、appAppSecret，凭证也是有时限性的。微信也对用户的信息进行加密后返回，比如运动步数，开发者必须请求加密密钥才能把信息解密。 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>web</category>
        <category>web 安全</category>
      </categories>
      <tags>
        <tag>web 安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[规范代码]]></title>
    <url>%2F2019%2F02%2F20%2F%E8%A7%84%E8%8C%83%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[返回结果处理返回结果有，后端向其他服务请求、后台给前端返回结果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 后台向其他服务请求$result = curlGet($url);if ($result) &#123; $rs = json_decode($result, true); return $rs;&#125; else &#123; return false;&#125;# 后台给前端返回public function returnResult($res)&#123; if ($res) &#123; if ($res['ret'] == 0) &#123; // 0 返回成功，返回data，携带 msg 默认是"success" return returnData($res['data']); &#125; // 1 返回失败，携带msg return returnError($res['data']); &#125; return returnError('请求其他服务接口失败');&#125;# 返回结果封装function returnError($msg = 'error', $ret = 1, $status = 200, $type = 0)&#123; return buildResponse($ret, $msg, $status, $type);&#125;function returnData($data, $ret = 0, $msg = 'success', $type = 0)&#123; return buildResponse($ret, $msg, 200, $type, $data);&#125;function buildResponse($ret = 0, $msg = '', $status = 200, $type, $data = array())&#123; $info = array( 'ret' =&gt; $ret, 'msg' =&gt; $msg ); if ($data) &#123; $info['data'] = $data; &#125; if ($type) &#123; return response(json_encode($info, $type), $status)-&gt;header('Content-Type', 'application/json'); &#125; else &#123; return response(json_encode($info), $status)-&gt;header('Content-Type', 'application/json'); &#125;&#125; controller/model 职责明确controller处理请求携带的参数，model返回的数据库数据。在model 就是直接利用参数，对数据库的操作。比如1234567# controller 判断参数timesif (!isset($params['times']) || count($params['times']) != 2 || $params['times'][0] &gt; $params['times'][1]) &#123; return '时间选择错误';&#125; # 毫秒转秒 millisecondToSecond = 1000$params['times'][0] = intval($params['times'][0] / config('constants.millisecondToSecond')); 有时还在controller/model 中间再加一层，在Repositories 目录文件中对model 取出的数据进一步处理。其他controller 要使用，就先在Providers 绑定interface—&gt;实现类, laravel会通过controller 构造函数注入给它。 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>改善代码</category>
        <category>重构</category>
      </categories>
      <tags>
        <tag>规范代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel 利用redis 的发布订阅保持数据一致性]]></title>
    <url>%2F2019%2F01%2F20%2Flaravel%20%E5%88%A9%E7%94%A8redis%20%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E4%BF%9D%E6%8C%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%2F</url>
    <content type="text"><![CDATA[保持数据一致性项目服务之间共用配置信息可以存储在远程的redis，怎样保存数据的一致性是个问题。可以使用redis 的发布订阅功能及时同步数据，思路 数据有变化的服务更新远程redis，并publish key 值到频道 订阅了数据的服务就会收到信息并去同步数据 可以把更新操作加到任务队列，这样就可以把业务和redis 处理分开。用laravel 这样实现123456789101112131415161718192021222324252627282930313233# controller public function updateConfig(Request $request)&#123; // 其他逻辑... // 分发任务到队列 cacheJob::dispatch('setCacheData', $request-&gt;all());&#125;# 命令创建任务 php artisan make:job cacheJobclass cacheJob implements ShouldQueue&#123; public function __construct($callback, $arguments) &#123; $this-&gt;callback =$callback; $this-&gt;arguments =$arguments; &#125; public function handle() &#123; call_user_func($this-&gt;callback, $this-&gt;arguments); &#125; # setCacheData public function setCacheData($params) &#123; // set.... $value = $params['data']; $this-&gt;redis = $this-&gt;getRedis(); $this-&gt;redis-&gt;set('dataKey', $value); // publish 比如频道名test $this-&gt;redis-&gt;publish('test', 'dataKey'); &#125; &#125; 接下来再启动php artisan queue:work 去处理队列里面的任务。可以用supervisor 管理该进程，设置随系统启动，启动的进程个数。 那些订阅远程redis test 频道的客户端就会收到同步信息，可以在需要订阅数据的服务所在机器上简单建一个订阅服务，一旦收到信息就同步。如下图 subscribe/publish 在同一台机器上，可以是不相关的两个服务。在subscribe 利用laravel构建自定义命令，别忘记在Console/Kernel.php 添加命令类。同样利用surpvisor 管理订阅进程，这样就可以保持数据一致性了！1234567891011# php artisan make command subscribeTestclass subscribeTest extends Command&#123; public function handle() &#123; $this-&gt;redis = $this-&gt;getRedis(); $this-&gt;redis-&gt;subscribe(['test'], function ($message) &#123; // 获取数据.... $this-&gt;getData($message); &#125;); &#125;&#125; 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>web</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>发布订阅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wkhtmltox实现 md转 pdf]]></title>
    <url>%2F2019%2F01%2F08%2Fwkhtmltox%20md%E8%BD%AC%20pdf%2F</url>
    <content type="text"><![CDATA[doc 是用来展示开发人员写的项目文档的服务，现在要添加一个md2pdf 的下载功能，下面说一下自己是怎样用wkhtmltox实现 md转 pdf doc 实现过程下面是开发文档展示的过程，只需看wkhtmltox 实现md 转pdf 可以忽略 文档写在仓库 docData，每次commit 时利用git-hook 触发http 请求给服务mcdoc api doc 服务会pull 文档到服务器指定目录，再读取目录和目录下的md/sql 文件，用于前端发挥展示。在doc 是这样实现的，解析md 文件提取标题，和内容返回前端 doc 接收到docData 请求会自动pull docData，更新文档 实现 wkhtmltox考虑到转换的效果、性能，选择在后端完成 选择利用js 的实现可以参考这里 在服务器安装服务，再通过php 扩展实现，不借助其他服务转pdf 的效果往往不是很好 后端的一些尝试 tc-lib-pdf不用其他安装服务，只借助一个php 扩展，但是对md 代码块中文字体显示不出来 安装pandoc，这个软件很强大各种格式都可以转。但要安装相应的latex 引擎，过程繁琐（甚至还会碰到C库不支持），而且只是用来转一个md 真是大材小用。 wkhtmltox php，是一个html2pdf 的工具。看起来好像不可以，稍微改变一下思路是可以的！ 普遍问题是支持css和中文，在服务器上安装软件费时 实现思路参考浏览器的思路，先把md 转成html 标签，再人为赋予它md css，这样md 文件就变成html 文件了，再利用wxhtmltox 转成pdf。 md格式 转成html 标签可以参考这个 需要给上面的html 标签加上css 样式，md csss 戳这里 wkthtmltox 的php 扩展 wkhtmltopdf 本身是没有问题的，可能有的扩展不好用，使用扩展遇到问题，可以在issue 中查找解决方法。记得设置css 页面大小A4 纸，否则一旦超出宽度 pdf 显示不全哦！12345678910111213141516171819# A4 css$divStart = &quot;&lt;div class=\&quot;page\&quot;&gt;&quot;;$divStart = &quot;&lt;/div&gt;&quot;;.page &#123; width: 21cm; min-height: 29.7cm; padding: 2cm; margin: 1cm auto; border: 1px #D3D3D3 solid; border-radius: 5px; background: white; box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);&#125;# 代码块设置换行 csspre &gt; code &#123; white-space: pre-wrap;&#125; 理解浏览器显示md 文件是把md 转成 html 标签，再加上样式。引擎也是起到同样得作用，明白这一点就可以避开安装引擎这个坑！ wxhtmltox 安装123456789# 1. 获取安装包wget https://github.com/wkhtmltopdf/wkhtmltopdf/releases/download/0.12.4/wkhtmltox-0.12.4_linux-generic-amd64.tar.xz# 2. 解压到 /usr/local/wkhtmltox/tar -xf wkhtmltox-0.12.4_linux-generic-amd64.tar.xz -C /usr/local# 3. 添加path /usr/local/wkhtmltox/binecho &apos;export PATH=/usr/local/wkhtmltox/bin:$PATH&apos; &gt;&gt; /etc/profilesource /etc/profile php 实现123456789101112131415161718192021222324252627if (!is_dir($dirPDF)) &#123; mkdir($dirPDF, 0755, true);&#125;// 生成HTML str， 人为加md css$res = MdDocHelper::getInstance()-&gt;getFileContent($app, $md);$content = MarkdownExtra::defaultTransform($res[&apos;data&apos;]);$content = str_replace(&apos;&lt;pre&gt;&apos;, &apos;&lt;pre class=&quot;prettyprint linenums&quot;&gt;&apos;, $content);$content = str_replace(&apos;&lt;a href=&apos;, &apos;&lt;a target=&quot;_blank&quot; href=&apos;, $content);$meta = &quot;&lt;meta http-equiv=\&quot;content-type\&quot; $divStart = &quot;&lt;div class=\&quot;page\&quot;&gt;&quot;;$mdCSS = config(&apos;mdcss&apos;);$divEnd = &quot;&lt;/div&gt;&quot;;$html = $meta.$mdCSS.$divStart.$content.$divEnd;// 开始转 pdf$pdf = new Pdf($html);$pdf-&gt;setOptions([ &apos;binary&apos; =&gt; config(&apos;mcdoc.wkhtmltopdfPath&apos;),]);if (!$pdf-&gt;saveAs($pathPDF)) &#123; $error = $pdf-&gt;getError(); return [ &apos;res&apos; =&gt; 1, &apos;msg&apos; =&gt; $error ];&#125; 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>web</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>wkhtmltox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式和复合模式]]></title>
    <url>%2F2018%2F12%2F18%2F%E4%BB%A3%E7%90%86%E5%92%8C%E5%A4%8D%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式代理模式定义，为另外一个对象提供一个替身以控制对这个对象的访问，是一个控制对象访问的模式。常用的几种控制访问方式有 远程代理控制访问远程对象 保护代理基于权限控制对对象访问，如java 动态代理 假设现在有一个远程的饮料贩卖机器，想在本地监控贩卖情况，就可以在本地产生一个远程的代理对象，本地程序通过本地远程代理来和远程真实对象进行通信。这样客户所做的就像在做远程调用，但是其实只是调用本地代理对象上的方法。再由代理处理所有网络通信的底层细节。 保护代理，如果一个对象里面的方法不是对每一个对象都是公开的，就可以为对象创建保护代理，每次调用对象方法时触发保护。 假设有一个帮忙实现约会的服务系统，这套系统能鼓励顾客找到可能的配对对象。系统有一个Person bean 对象，允许设置或取得一个人的信息。12345678910111213141516171819202122232425262728293031323334353637383940414243public interface PersonBean&#123; String getName(); String getGender(); // 取得兴趣爱好 String getInterests(); // 取得评分1~10 int getHotOrNotRating(); void setName(String name); void setGender(String gender); // 设置兴趣爱好 void setInterests(String interests); // 每一次评分都会，再计算平均评分 void setHotOrNotRating(int rating);&#125;// PersonBean 实现public class PersonBeanImpl implements PersonBean&#123; String name; String gender; String interests; int rating; int ratingCount = 0; public String getName()&#123; return name; &#125; public int getHotOrNotRating()&#123; if(ratingCunt == 0) return 0; return (rating/ratingCount); &#125; // 其他方法 ..... public void setInterests(String interests)&#123; this.interests = interests; &#125; public void setHotOrNotRating(int rating)&#123; this.rating += rating; ratingCount++; &#125;&#125; 但是不久就会有人抱怨有人居然篡改了我的兴趣，还有有人居然给自己评高分，以拉高自己的HotOrNotRating 值。所以顾客不可以给自己评分，也不可以修改别人的信息。我们可以为PersonBean 创建保护代理，先看看类图 在这里PersonBean 就是RealSubject， 图中proxy是由Java 产生的，而且实现了完整的PersonBean 接口 InvocationHanlder 是由我们提供的，Proxy 上的任何方法调用都会被传入此类，由它控制对RealSubject 方法的访问 接下来看看具体的代码实现，创建控制自己对主题访问的对象OwnerInvocationHandler，控制别人对主题访问的NonOwnerInvocationHandler 代码类似12345678910111213141516171819202122232425import java.lang.reflect.*;// InvocationHandler 是reflect 里面的接口，实现其中的invoke 方法public class OwnerInvocationHandler implements InvocationHandler&#123; PersonBean Person; public OwnerInvocationHandler(PersonBean person)&#123; this.person = person; &#125; public Object invoke(Object proxy, Method method, object[] args) throws IllegallAccessException&#123; try&#123; if(method.getName().startsWith("get"))&#123; return method.invoke(perosn, agrs); &#125;else if(method.getName().equals("setHotOrNotRating"))&#123; // 自己不能给自己评分，调用此方法时抛异常 throw new IllegalAccessException(); &#125;else if(method.getName().startWith("set"))&#123; return method.invoke(perosn, agrs); &#125; &#125;catch(InvocationTargetException e)&#123; e.printStackTrace(); &#125; return null; &#125;&#125; 创建getOwnerProxy 代理的方法返回personBean 对象，该代理用于保护自己对personBean 的访问。123456789101112131415161718192021// 创建getOwnerProxy 代理PersonBean getOwnerProxy(PersonBean person)&#123; // Proxy 是java reflect 包里面的类 return (PersonBean)Proxy.newProxyInstance( person.getClass().getClassLoader(), person.getClass().getInterfaces(), new OwnerInvocationHandler(person) );&#125;// 类似的getNonOwnerProxy()，返回NonOwnerInvocationHandler 的代理// 测试一下,PersonBean personA = new PersonBean();personBean ownerProxy = getOwnerProxy(personA);try&#123; // 代理会触发 OwnerInvocationHandler invoke() ownerProxy.setHotOrNotRating(10);&#125;catch (Exception e)&#123; System.out.println('Canot set rating from owner proxy);&#125; Java 在java.lang.reflect 包中有自己的代理支持，利用这个包可以再运行时动态创建一个代理类，实现一个或多个接口，并将方法的调用转发到你所指定的类。因为实际的代理类是来运行时创建的，所以称这个Java 技术为：动态代理。 复合模式复合模式：结合两个或两个以上的模式，组成一个解决方案，解决一再发生的一般性问题。我们看看 mvc 模式在web 中的应用，里面也用了好几种设计模式 策略模式，controller 对客户端请求的响应，策略对象是controller，同一个请求可以更换不同的controller 来处理。这不就是策略模式 组合模式，网页由HTML 描述，内部很类似形成组合的对象系统 观察者模式，当model 改变状态时，视图间接地从控制器收到了相当于通知的东西，控制器甚至把模型Bean 给视图 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>改善代码</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell script 入门]]></title>
    <url>%2F2018%2F12%2F15%2Fshell%20script%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[为什么学shell操作系统其实是一组软件，控制整个计算机硬件如cpu调度，内存、磁盘存储输入输出是操作系统的内核（Kernel）。通常这组软件是不允许被没有管理能力的终端用户随便使用的，但总是需要让用户操作系统的，用户可以通过壳程序（shell）来达到目的。壳程序是提供给用户去操作系统的一个接口，像ls、mkdir这些常用的命令都是封装好的独立应用程序，它们可以利用壳程序再通过内核去操作系统。 linux 很多地方都利用了shell script，shell 在系统管理是很好的工具，服务的启动关闭就是通过它来控制的。所以学习shell 有助于弄清楚linux的来龙去脉，是进一步理解linux的方式。 但是shell script 不擅长大量数值运算，它调用外部函数库耗cpu。linux 默认的shell 是bash，它规范了接口的语法。学习shell 可以参考 认识和学习bash 学习shell scripts shell 操作环境利用系统提供的命令如，ls/mkdir/rm/mv 等，或者通过./xx.sh 执行已写好的可执行脚本。必须先搞清楚系统查询执行这些命令的顺序，所以在当前目录执行脚本文件时要加 ./ 代表相对，否则报找不到文件错误 以相对/绝对路径运行命令，例如『 /bin/ls 』或『 ./ls 』； 由 alias 找到该命令来运行； 由 bash 内建的 (builtin) 命令来运行； 透过 $PATH 这个变量的顺序搜寻到的第一个命令来运行。 我们一登入linux 进入shell 之后，能使用一堆有用的变量，这是因为系统有一些环境配置文件的存在。bash 在启动时直接就读取这些配置文件，以规划好bash 的操作环境。配置文件有分全体系统的配置文件以及用户个人偏好设置文件。 /etc/profile 系统整体的配置 ~/.bash_profile ~/.bash_login ~/.profile 属于使用者个人配置 同时也必须理解login shell 和 non-login shell 的概念，因为通过这两种进入的bash 环境，读取配置文件的顺序不同。 login shell，取得bash 需要完整的登录流程，比如通过secureCRT ssh 方式得到的bash 环境。 non-login shell，取得bash 接口的方法不需要重复的登陆举动，比如你在原本的bash 环境再次下达bash 命令，没有输入账号密码，那第二个bash 子程序也是non-login shell。所以在写脚本命令前一般都会配置环境变量 下面是这两种方式读取配置文件的顺序，图来自鸟哥书籍。实线是主线流程，虚线是被调用的配置文件。图中是login shell 完整顺序图，而non-login shell 只读 ~/.bashrc 简单 shell script下面是简单shell script 的格式，PATH 很重要1234567891011121314#!/bin/bash# Program:# This program is a easy shell script# History:# 2019/07/23 lics First releasePATH=/usr/local/php/bin:/usr/local/node/bin:/usr/localexport PATH# 文件名date=$(date +%Y%m%d)file=$&#123;date&#125;# file 加不加&#123;&#125;只是习惯问题touch &quot;$file&quot; shell script 运行区别 sh script 或者 ./script ，利用直接运行的方式运行script，该script 都会使用一个新的bash 环境来运行脚本内的命令。script 是指子程序的bash 内运行的！注意的是，在子程序的各项变量或者动作将会结束而不会回到父程序中。 source script ，在父程序中运行脚本，script 的各项动作都会在父程序中生效。所以我们修改了/etc/profile 里面的环境变量时，都会运行source /etc/profile 使其有效，否则要重新登入才行。 exec 方式 bash 语法在了解shell 的作用，操作环境，运行方式之后，可以进一步学习bash的基本语法。比如 bash 变量 bash 通配符和特殊符号 ()代表中间为子shell 的起始和结束 判断式，关于文件类型，文件权限，整数，字符串 shell script 的默认变量 $0，$1 $# ：代表后接的参数『个数』，以上表为例这里显示为『 4 』； $@ ：代表『 “$1” “$2” “$3” “$4” 』之意 $* ：代表『 “$1c$2c$3c$4” 』，其中 c 为分隔字节，默认为空白键 条件判断式，if–then/case—esac/function 回圈，while–do/for—-do 定时服务器脚本通过一些例子来熟悉shell script， 写一个定时同步服务器时间的 script 和网络时间同步 12345678# 安装ntpdate工具yum -y install ntp ntpdate# 设置系统时间与网络时间同步ntpdate cn.pool.ntp.org# 将系统时间写入硬件时间hwclock --systohc 定时同步，利用crontab 来执行定时脚本 1234567# 编辑crontabvim /etc/crontab# 添加定时任务，每6分钟同步一次*/10 * * * * ntpdate -u ntp.api.bz &amp;&amp; clock -wservice crond reload 自动连接mysql每次都要通过输入密码连接数据库，难免烦躁，可以把数据库密码放在每个文件中，然后写script 连接12345# 创建con_mysql脚本文件，密码在/data/save/mysql_root 内exec mysql -uroot -p$(cat /data/save/mysql_root) # 把con_mysql 所在目录添置PATH，在任何目录执行con_mysql 数据自动入库假如现在有很多.sql 和txt 文件数据要录入数据库中，我们可以写一个只要提供数据库名、文件所在目录名就可以完成目的的shell script。运行方式 [script] db_name [sql所在目录绝对路径]12345678910111213141516#!/bin/bashdatabase=$1backup_dir=$2if [ "$database" == "" -o "$backup_dir" == "" ] ; then echo "eg:bash $0 db_name data_dir" exitfimysql -uroot -p`cat /data/save/mysql_root` -e "CREATE DATABASE IF NOT EXISTS $&#123;database&#125;;"cd $&#123;backup_dir&#125;SQL_LIST=$(ls $&#123;backup_dir&#125; | /bin/grep sql)for sql_file in $&#123;SQL_LIST&#125;; do mysql -uroot -p`cat /data/save/mysql_root` $&#123;database&#125; &lt; $&#123;sql_file&#125;donemysqlimport --local -uroot -p`cat /data/save/mysql_root` $&#123;database&#125; *.txt script 更新项目版本在项目开发中，项目版本更新过程一般如下 本地环境完成，自测无误 将代码push github 在内测机器pull 项目，进行测试 在我们push 仓库后，每次都要手动去更新内测机器的代码，难免烦躁。可以写一个可视化操作界面，只需点击一个按钮，利用shell script 来完成git pull 和更新到内测机器相应项目目录的步骤 bash 常见用法在学习bash shell 脚本的过程中，如遇陌生语法可以在 学习bash、学习shell script这里，利用CTRL+F 查找学习。 awk 处理文件 12# 根据匹配规则[@=] 列分割文件内容，并且输出第一列数据$(echo $&#123;NAME&#125;|awk -F '[@=]' '&#123;print $1&#125;') 查看linux 命令是否存在 12345678# 将type composer的结果信息写到 垃圾桶黑洞装置/deb/null# 2&gt; 代表将执行命令结果的错误信息 写到文件# &amp;1 代表和前一个文件相同# || 如果左边命令不报错，则不执行右边type composer &gt;/dev/null 2&gt;&amp;1 || &#123; echo "require composer but it's not installed. Aborting"; exit; &#125; cp 一系列目录 12NEED_UPDATE_FILE = &apos;www scripts update deps&apos;； /bin/cp -rf $&#123;NEED_UPDATE_FILE&#125; release； 删除目录下的部分文件 123# find release 目录下文件且文件名为 *.svn*匹配# xargs 代表 rm -rf 的命令参数find release -type d -name &quot;*.svn*&quot; | xargs rm -rf 代表一系列目录，且去除目录下部分目录 1234567# 生成文件名，date xxx 是函数调用 xxx 是传参Date=`date "+%Y-%m-%d-%H%M%S"`TAR_FILE=web.oa.$Date.tar.gz# 打包文件，www/upload 除外NEED_UPDATE_FILE = 'www scripts update deps'；tar cfz $TAR_FILE $&#123;NEED_UPDATE_FILE&#125; --exclude=www/upload 执行远程命令 123456789# 连接远程机器，并执行命令ssh -p22 $PUBLISH_USER@$IP &quot;sudo mkdir -p $SERVER_DIR&quot;# $? 代表了执行命令的结果，0代表成功，127是失败if [ $? -gt 0 ] ; then echo &quot;远程创建目录失败&quot; exitelse scp -P 22 $TAR_FILE $PUBLISH_USER@$IP:/data/tmpfi 执行远程一系列命令 12# 通过这种方式ssh -p22 $PUBLISH_USER@$IP &quot;sudo mv /data/tmp/$&#123;TAR_FILE&#125; $&#123;SERVER_DIR&#125;;cd $&#123;SERVER_DIR&#125;;xxx;xxx&quot; 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>基础</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell script</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式和单件模式]]></title>
    <url>%2F2018%2F12%2F10%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式每次用new来实例化对象的时候，都是实例化具体的类，不是面向接口编程，而是实现；代码绑着具体类会导致代码更脆弱，更缺乏弹性，初始化也经常造成耦合的问题。 假设现在有家披萨Pizza 店，有很多披萨比如pizzaA、pizzaB、pizzaC、pizzaD，产生披萨的类一开始可能会这样写1234567891011121314151617181920212223Pizza orderPizza(String type)&#123; // Pizza 抽象类 ABCDE 是实现子类 Pizza pizza; if(type.equals("A"))&#123; pizza = new pizzaA(); &#125;else if(type.equals("B"))&#123; pizza = new pizzaB(); &#125;else if(type.equals("C"))&#123; pizza = new pizzaC(); &#125;else if(type.equals("D"))&#123; pizza = new pizzaD(); &#125;else if(type.equals("E"))&#123; pizza = new pizzaE(); &#125; // 披萨的其他加工步骤 pizza.prepare(); pizza.bake(); //烘烤 pizza.cut(); //切片 pizza.box(); //装盒 return pizza;&#125; 这个设计显然违背了 封闭——开放原则，如果pizza 种类增多，或者要去除一些不受欢迎的披萨，就必须修改orderPizza ，而这都是没有对变化封闭的原因。于是我们把创建pizza 那边代码搬移到简单的工厂SimplePizzaFactory123456789101112131415161718192021222324252627282930313233343536public class SimplePizzaFactory&#123; public Pizza createPizza(String type)&#123; // Pizza 抽象类 ABCDE 是实现子类 Pizza pizza = null; if(type.equals("A"))&#123; pizza = new pizzaA(); &#125;else if(type.equals("B"))&#123; pizza = new pizzaB(); &#125;else if(type.equals("C"))&#123; pizza = new pizzaC(); &#125;else if(type.equals("D"))&#123; pizza = new pizzaD(); &#125;else if(type.equals("E"))&#123; pizza = new pizzaE(); &#125; return pizza; &#125;&#125;// 修改 orderPizzapublic class PizzaStore&#123; SimplePizzaFactory factory; public PizzaStore(SimplePizzaFactory factory)&#123; this.factory = factory; &#125; public Pizza orderPizza(String type)&#123; Pizza pizza; pizza = factory.createPizza(type); // pizza 的其他方法 &#125;&#125; 我们来看一下引入这个简单工厂的类图设计， 上面只是一个简单的工厂设计，如果披萨店变得很多了怎么办，createPizza应该生产哪家披萨店的披萨呢？我们可以把pizzaStore 设计成一个抽象类123456789101112131415161718192021222324252627282930public abstract Class PizzaStore &#123; public Pizza orderPizza(String type)&#123; Pizza pizza; pizza = createPizza(type); pizza.prepare(); pizza.bake(); // pizza 其他制作方法 return pizza &#125; // createPiza 决定生产那个店的披萨，父类的orderPizza 和子类createPizza 解耦 abstract Pizza createPizza(String type);&#125;//披萨店Apubic class storeAPizzaStore extends PizzaStore&#123; Pizza createPizza(String type)&#123; if(type.equals("A"))&#123; return new storeApizzaA(); &#125;else if(type.equals("B"))&#123; return new storeApizzaB(); &#125;else if(type.equals("C"))&#123; return new storeApizzaC(); &#125;else if(type.equals("D"))&#123; return new storeApizzaD(); &#125; &#125;&#125; 在看看工厂方法的定义1abstract Product factoryMethod(String type) 工厂方法用来处理对象的创建，并将这样的行为封装在子类中。这样，客户程序中关于超类的代码就和子类对象创建代码解耦了。 工厂方法是抽象，依赖子类实现对象创建 工厂方法必须返回一个产品 工厂方法将客户代码和实际创建具体产品的代码分隔开 参数看情况是否需要 这样披萨的制作过程代码就是12345pizzaStore storeA = new storeAPizzaStore();Pizaa storeAPizzaB = storeA.orderPizza(&apos;B&apos;);pizzaStore storeB = new storeBPizzaStore();Pizaa storeBPizzaB = storeB.orderPizza(&apos;B&apos;); 再来看看利用该复杂工厂的设计类图， 单件模式在软件项目里面有些类只能有一个实例，比如线程池、缓存、对话框，日志等对象；如果制作出多个实例就会导致许多问题，比如程序的行为异常、资源使用过量，或者是不一致的结果。下面是一个经典的单件模式实现123456789101112131415161718public class Singleton&#123; private static Singleton uniqueInstance; // 其他有用的变量 // 构造器私有 private Singleton()&#123; // ... &#125; public static Singleton getInstance()&#123; if(uniqueInstance == null)&#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125; // 其他方法&#125; 单件模式就是，确保一个类只有一个实例，并提供一个全局访问点。但是尽管如此，如果是在多线程情况下使用的话，也有可能new 出了多个实例化对象。就是在第一次调用getInstance 创建对象时出了问题。解决多线程安全问题，一般可以这样123456789public static Synchronized Singleton getInstance()&#123; if(uniqueInstance == null)&#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance;&#125;// 或者在声明变量的时候 就实例化private static Singleton uniqueInstance = new Singleton(); 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>改善代码</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
        <tag>单件模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰者模式和命令模式]]></title>
    <url>%2F2018%2F12%2F06%2F%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰者模式现在有一家咖啡连锁店，咖啡如A、B、C、D多种，配料更是有蒸奶（Milk）、豆浆（Soy）、摩卡（Mocha）、奶泡（whip）等，咖啡店会根据加入的配料收取不同的费用。那怎样设计其中的单订系统呢，起初是这样设计的。看类图 其中 Beverage 是各饮料的基类，里面包含变量 描述，各个配料的布尔值，cost 计算配料的价格（该方法是具体的） 子类饮料 BeverageA，设置加入制定配料，重写cost() 方法，并调用父类的cost 计算配料钱，再加上饮料费用，计算出总额。 看起来4 个类就可以解决问题，但是一旦需求变动 调料的价格变动，要修改父类Berverage 代码 一旦出现新的饮料，得为Berverage 加成员变量 喝个冰茶，还得设置其他调料为false，真是麻烦 有人来个 双倍 Milk 调料，怎么办？ 我们对类的设计，没有做到对扩展开发，对修改关闭（开发——关闭原则）。我们的目标是允许类容易扩展，在不修改现有代码的情况下就可搭配新的行为，弹性应对改变的需求。 做到开放-关闭 原则，如观察者模式。不需要每一部分都这样设计，要花费很多时间，关注在设计中最有可能改变的地方应用开放-关闭原则。 如果现在有这样一种设计来实现上面的需求，如下 实现过程 BerverA 是被装饰者，cost() 返回BerverA 的费用 Mocha 是装饰者，cost() 调用BerverA cost ()，返回Mocha、BerverageA 总费用 whip 是装饰者，cost调用Mocha cost()，返回Whip、Mocha、BerverageA 总费用 其中饮料BerverA 继承Berver 饮料基类，Mocah/Whip 继承了装饰者基类（该类已继承Berverage ），类图如下 调料装饰者，除了实现cost之外，还实现了getDescription()，现在看具体代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 组件 饮料 Berveragepublic abstract class Berverage&#123; String description = 'Unkown Berverage'; public String getDescription()&#123; return description; &#125; public abstract double cost();&#125;// 装饰者抽象类 调料public abstract class CondimentDecorator extends Beverage &#123; // 所有调料装饰者 重新实现 getDescription public abastract String getDescription();&#125;// 具体组件 饮料 BeverageApublic class BerverageA extends Beverage &#123; public BerverageA() &#123; // 该变量来自父类 description = 'BeverageA'; &#125; public double cost() &#123; return 3.99; &#125;&#125;// 饮料 BeverageBpublic class BeverageB extends Beverage &#123; public BeverageB() &#123; // 该变量来自父类 description = 'BeverageB'; &#125; public double cost() &#123; return 2.29; &#125;&#125;// 具体装饰者 调料 摩卡（mocha）public class Mocha extends CondimentDcorator &#123; Beverage beverage; // 传入 被装饰者 或者 其他装饰者，利用多态的特性 public Mocha(Beverage beverage) &#123; this.beverage = beverage; &#125; // 重新实现 getDescription 可以连调料都输出 public String getDescription() &#123; return beverage.getDescription + ', Mocha'; &#125; public double cost()&#123; return 1.11 + beverage.cost(); &#125;&#125;// 具体装饰者 调料 蒸奶（Milk）public class Milk extends CondimentDcorator &#123; Beverage beverage; // 传入 被装饰者 或者 其他装饰者，利用多态的特性 public Milk(Beverage beverage) &#123; this.beverage = beverage; &#125; // 重新实现 getDescription 可以连调料都输出 public String getDescription() &#123; return beverage.getDescription + ', Milk'; &#125; public double cost()&#123; return 13.11 + beverage.cost(); &#125;&#125; 就是这样实现装饰者模式的，接下来我们测试一下123456789101112public class Test&#123; public static void main(String args[])&#123; Beverage beverage = new BeverageA(); // 加入调料 摩卡（mocha） beverage = new Mocha(beverage); // 双倍 摩卡（mocha） 哈哈！ beverage = new Mocha(beverage); // 加入 蒸奶（Milk） beverage = new Milk(beverage); System.out.println(beverage.getDescription() + '价格,' + beverage.cost()); &#125;&#125; 以上就是装饰者模式的全部实现了，其定义是，装饰者模式动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承共有弹性的替代方案。 java.io 类 java.io 包内的类太多了，其中很多类都是装饰者，如图用装饰者将功能结合起来以读取文件数据， BufferedInputStream 是一个具体的装饰者，加入缓冲输入改进性能；用realine() 一次读取一行文件增强接口 LineNumberInputStream 也是一个具体的装饰者，加上了计算行数的能力。 命令模式让我们从餐厅订单的工作流程来认识命令模式，顾客在订单上写好菜单，把订单交给女招待；女招待拿了订单就放在订单柜台，然后喊了一句 “单订来了！”；最后厨师就根据单订准备餐点。详细分析过程就是， 顾客知道自己想要什么，createOrder() 创建一份订单 女招待利用 takeOrder()，拿到订单并且调用 orderUp() 方法通知厨师开始准备餐点 厨师根据指令准备餐点 其中以上过程，创建的单订对象里面包含厨师（命令接收者）和告诉厨师的一系列指令，并对外只暴露一个orderUp()通知执行命令；女招待（调用者）根本不关心谁是命令接收者，厨师也不关心被谁触发命令，被谁调用。 我们用遥控器遥控灯泡亮暗的例子来观察代码实现，当我们按下遥控器（调用者）亮灯按钮（命令对象）时，灯（接收者）亮了。命令对象包含了接受者和对接受者的指令，让所有的命令对象实现相同的包含一个方法的接口，在餐厅例子中叫orderUp，一般惯用execute123public interface Command &#123; public void execute();&#125; 现在实现打开电灯的命令，接受者Light 有on() 和 off()123456789101112public class LightOnCommand implements Command &#123; Light light; public LightOnCommand(Light light)&#123; this.light = light; &#125; // 对外暴露 execute 给调用者 public void execute()&#123; light.on(); &#125;&#125; 使用命令对象，假设我们有个遥控器，按下按钮对应的命令对象插槽12345678910111213141516171819202122232425public class SimpleRemoteControl &#123; Command slot; public SimpleRemoteControl()&#123;&#125; public void setCommand(Command command)&#123; slot = command; &#125; public void buttonWasPressed()&#123; slot.execute(); &#125;&#125;// Testpublic class RemoteControlTest &#123; public static void main(String[] args)&#123; SimpleRemoteControl remote = new SimpleRemoteControl(); Light light = new Light(); LightOnCommand ligthOn = new LightOnComand(light); remote.setCommand(lightOn); remote.buttonWasPressed(); &#125;&#125; 以上就是用命令模式实现按下遥控器按钮，下达命令使灯亮的全部代码。命令模式将“请求”封装成对象，以便使用不同的请求、队列来参数化其他对象。 一个命令对象通过在特定接收者上绑定一组动作来封装一个请求。要达到这一点，命令对象将动作和接收者包进对象中，这个对象只暴露出一个execute() 方法，当此方法被调用的时候，接收者就会进行这些动作。从外面来看，其他对象不知道究竟哪个接收者进行了那些动作，只知道如果调用execute()方法，请求的目的就能达到。命令模式类图 laravel 消息队列现有一个日志收集服务系统要接收来自数据埋点的数据，利用laravel 的消息队列来处理请求。处理过程是利用controller 先把真正处理请求函数和数据联系起来，再启动work 进程消费这些任务，最终完成数据入库。利用命令模式来理解这样过程 controller（客户），创建命令对象，把真正处理请求的函数（接受者）和参数用json 字符串保存到redis/mysql work 进程（调用者），可用supervisord 管理启动。读取redis 中命令对象，调用接收者完成任务 真正处理请求的函数（接收者） 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>改善代码</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>装饰者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式和观察者模式]]></title>
    <url>%2F2018%2F12%2F02%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[为什么要设计模式软件开发中，我们花费更多的时间在需求变化和维护项目上，想更好得应对变化需要建立弹性的，可维护、可应对变化的设计。而知道抽象、继承、多态，并不能马上成为面向对象设计者，设计模式正是告诉我们如何组织类和对象以解决某种问题，所以需要设计模式。 其实我们正在使用的框架封装了很多设计模式，但是我们感觉不到。可以先让设计模式进入你的脑海，再尝试使用。 策略模式现在有个模拟鸭子的游戏，游戏中出现各种鸭子，比如一边游泳，一边呱呱叫，每个鸭子的外形不同。使用面向对象（OO）技术，设计类图如下 需求变动，有些鸭子要添加飞的特性，会飞的特性代码添加在哪里呢？ 父类 Duck 的实现代码中，这样会导致全部鸭子都会飞，明显不行。 解决方案，可以把 fly() 覆盖掉，使得鸭子不会飞。但也有鸭子会飞不会叫，采用同样的方法覆盖 quack() 缺点，很难知道鸭子全部行为、代码在多个子类中重复 利用接口，把 fly() quack() 方法接口出去 缺点，此时行为代码写在鸭子子类中，代码无法复用，如果有48个鸭子都要稍微修改一下飞行的行为，很容易出错 上面两种方式都不能解决问题，那是因为我们没有遵循设计原则 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 这样我们可以把飞和叫 的行为抽出成类，独立出去。类图如下 现在父类Duck 中只要 FlyBehaior QuackBehavior 两个行为接口引用就行了，在利用多态特性去调用飞和叫的方法，而且具体的方法实现也不会出现在Duck 或者Duck 子类中。 Duck 代码实现如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public abstract class Duck&#123; FlyBehavior flyBehavior; QuackBehavior quackBehavior; public Duck()&#123; &#125; public void performFly()&#123; flyBehavior.fly(); &#125; public void performQuack()&#123; quackBehavior.quack(); &#125; public void swim()&#123; // ..... &#125;&#125;// 飞行为public interface FlyBehavior&#123; public void fly&#123;&#125;;&#125;public class FlyWithWings implements FlyBehavior &#123; public void fly()&#123; //... &#125;&#125;public class FlyNoWay implements FlyBehavior &#123; public void fly()&#123; // ... &#125;&#125;// 实现 一个鸭子public class MallardDuck extends Duck &#123; public MallardDuck()&#123; quackBehavior = new Quack(); flyBehavior = new FlyWithWings(); &#125; public void dispaly()&#123; // ... &#125;&#125; 这样就可以很方便添加飞行为的其他实现，这时全部类图 当然Duck 也可以提供set flyBehavior实现类的对象，使得鸭子对象在运行时能改变自己飞的行为形式123public void setFlyBehavior(FlyBehavior fb)&#123; flyBehavior = fb;&#125; 策略者模式：定义算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。其实在 重构 优化switch/case 语句中使用的就是策略模式。 观察者模式现在有一个气象站，它是获取湿度、温度、气压数据的物理装置，WeatherData追踪气象站的数据变化，并且更新到报告班板，如图 需求： WeatherData 类有getter 方法，可以取得温度、湿度、气压、三个测量值。当测量数据发送变化时，WeatherData measurementsChanged() 方法就会被调用（先不管它是如何被调用的，只要记住一点数据变化会调用此方法） 需要实现三个布告板，目前状况布告、气象统计布告、天气预报布告；并且系统需可扩展，实现让其他开发人员建立定制的布告板，用户可以随便添加或者删除 任何布告板。 一般我们是这样实现的1234567891011121314public class WeatherData &#123; // 实例变量声明 pubic void measuremetnsChanged()&#123; float temp = getTemperature(); float humidity = getHumidity(); float pressure = getPressure(); currentConditionsDisplay.update(temp, humidity, pressure); statisticsDisplay.update(temp, humidity, pressure); forecastDisplay.update(temp, humidity, pressure); &#125; // 这里WeatherData 其他方法&#125; 这样实现由缺点 对于每个新的布告板，我们都得修改代码，我们尚未封装改变的部分 布告板没有实现一个共同的 接口，至少update 看来参数没有发生变化 我们无法在运行时动态地添加、删除布告板 利用观察者模式来设计，观察者模式就类似在生活中我们 向杂志社订阅或者取消订阅报纸、杂志。结合模型对象的编程思想，杂志社需要提供 订阅、取消订阅、通知用户的方法，而订阅者肯定要提供一个 让杂志社联系上自己的方法。联系上面的需求，画出类图 所以我们可以把实现上面需求的类图设计为 实现代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public interface Subject &#123; public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifybservers();&#125;public interface Observer &#123; public void update(float temp, float humidity, float pressure);&#125;public interface DisplayElement&#123; public void display();&#125;// 实现 weatherDatapublic class WeatherData implements Subject &#123; private ArrayList observers; private float temperature; private float humidity; private float pressure; public WeatherData()&#123; observers = new ArrayList(); &#125; public void registerObserver(Observer o)&#123; observers.add(o); &#125; public void removeObserver(Observer o)&#123; int i = observers.indexof(o); if(i &gt;= 0)&#123; observer.remove(i); &#125; &#125; public void notifyObservers()&#123; for(int i=0; i&lt; observers.size(); i++)&#123; Observer observer = (Observer)observers.get(i); Observer.update(temperature, humidity, pressure); &#125; &#125; // 测量数据改变，该方法会被调用 public void measurementsChanged()&#123; notifyObservers(); &#125;&#125; // 创建布告板 public class CurrentconditionsDisplay implements Observer, DisplayElement &#123; private float temperature; private float humidity; private Subject weatherData; public CurrentconditionsDisplay(Subject weatherdata)&#123; this.weatherData = weatherData; weatherData.registerobserver(this); &#125; public void update (float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; display(); &#125; public void display()&#123; // .... &#125;&#125; 观察者模式，定义了对象之间一对多依赖，当一个对象改变状态，它的所有依赖者都会接收到通知并自动更新 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>改善代码</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重构]]></title>
    <url>%2F2018%2F11%2F25%2F%E9%87%8D%E6%9E%84%2F</url>
    <content type="text"><![CDATA[技术是为了更好得解决变动的需求，要做到这一点，必须写出优雅的代码。这需要重构， 这是一个开发人员从初级到中级的必经之路 重构是目的，设计模式是到达的方式，这需要一直的训练 重构是什么 什么是重构，调整软件内部结构，提高理解性，降低修改成本；但不改变软件可观察行为（功能） 何时重构，不用专门拨时间进行重构，应该是随时随地进行的。当想为程序添加特性，但代码结构使你不是很方便达成目的，可考虑先重构。应该好程序应满足下面条件 容易阅读 所有逻辑都只在唯一地址指定 新的改动不会危及现有行为 尽可能简单表达条件逻辑 重构难题，数据库、修改接口 重构和性能，重构代码有时会为了改善结构而牺牲性能，尽管如此你也不必要求代码处处高性能。一视同仁优化所有代码，90%工作是白费的，你优化的代码很少被运行。所以，编写良好代码结构，不对性能投以特别的关注，直至进入性能优化阶段（后期阶段）。 代码的坏味道 重复代码，提取方法，把方法提取到父类 过长函数，提取方法 难点：怎样解决参数过多的问题 过大的类，提取类或者子类 过长参数列 由于需求变动，导致代码块多处逻辑都修改（不符合逻辑在唯一处）。 依赖情结，类中某方法，太过依赖其他类数据，move it 数据泥团，提取出类 令人迷惑的暂时字段？ 过多的注释，好代码，注释是多余的，写注释前请先尝试重构。 提炼函数（Extract Method） extract Method 难点：源函数参数，局部变量(个数越多，越难extract) 临时变量 Inline Method，不需要extract 函数，提取了之后感觉这一中间层很别扭。 函数体来代替 函数名 查询函数代替临时变量：临时变量局限于某个函数，函数可以在对象整个生命周期中使用。 内联临时变量，引入解释临时变量 1234567891011121314151617181920212223# 内联临时变量let xx = aaa.b;if(xx &gt;21)&#123; dosomething;&#125;&lt;!-- 之后 --&gt;if(aaa.b &gt;21)&#123; dosomething;&#125;# 引入解释临时变量if(aaa.bb.c.indexof(&apos;xx&apos;) &gt; -1 &amp;&amp; ddd.ee.f &gt; -1)&#123; dosomething;&#125;&lt;!-- 之后 --&gt;const a = aaa.bb.c.indexof(&apos;xx&apos;) &gt; -1;const b = ddd.ee.f &gt; -1;if(a &amp;&amp; b)&#123; dosomething;&#125; 分解临时变量，当一个临时变量被赋值了两次，可以引入两个独立 临时变量 i = i + xx 形式不要拆解 拒绝对函数参数赋值 引发很多，函数引用传参的问题，java 更多是提倡按值传递。 js 动态语言，很多都是对象，注意 深拷贝 的问题 类来代替函数（replace method with Object） 当一个函数局部变量很多，逻辑复杂，extract 困难。就把函数升级为类 替换算法，简单逻辑替换复杂逻辑 引入解释临时变量，和抽取函数选择哪一种。 对象之间搬移特性 搬移函数、搬移字段，如果一类里面包含太多行为，或者里面的函数和其他类耦合高，被调用次数比驻类（宿主类）还多。可以考虑搬移函数，搬移之前，往往先进行搬移字段，如果字段被驻类很多函数调用，先进行自我封装（self-Encapsulation）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class A ... private B b; private double xx; double xxx1(double x1, int x2)&#123; return xx * x1 * x2; &#125; double xxx2(double x1, int x2)&#123; return xx * x1 * x2; &#125; # 将 xx 般至B里面&lt;!-- A 进行自我封装 --&gt;class A ... private B b; private double xx; double xxx1(double x1, int x2)&#123; return xx * x1 * x2; &#125; double xxx2(double x1, int x2)&#123; return xx * x1 * x2; &#125; private void setxx(double arg)&#123; xx = arg; &#125; private double getxx()&#123; return xx &#125; &lt;!-- xx 移到B --&gt;class B ... private double xx void setxx(double arg)&#123; xx = arg; &#125; double getxx()&#123; return xx; &#125; &lt;!-- 这样，就算A中有很多对xx 的引用，就只要修改--&gt; private void setxx(double arg)&#123; // xx = arg; b.setxx(arg); &#125; private double getxx()&#123; // return xx return b.getxx(); &#125; 其实自我封装，也是多加了一层。一层函数调用 提炼类，类内联化（Inline Class），一个类太大，抽象得不合理，应该提炼。内联是指一个类没有承担足够多的责任，不应该单独存在，将这个类内联到其他类中。 隐藏委托关系，移除中间人，如下，B把责任全部都委托给了C，如果A 完全不知道C 的存在，则称为隐藏委托关系。有时候抽象的目的就在于此，减少耦合。但如果B 这个中间人（Middle Man）越来越大时，干脆就直接移出中间人B，直接调用C 1# A调用 B，B再调用 C获得结果后，给 A返回 引入本地函数，或者本地扩展，当某语言的标注库函数提供的功能无法满足开发需求，可以引入本地函数，相当于java 函数重写 1234567891011121314151617# 比如微信小程序request 封装一下function request(option)&#123; // dosometing(); wx.request(option);&#125;# 调用自己写的request 函数requset(&#123; url: url, method: 'GET', success: function(res) &#123; // xxx &#125;, fail: function(err) &#123; // xxx &#125; &#125;) 重新组织数据 自封装字段， 在类里面操作字段用函数，不直接访问。是否封装，一直以来存在争议。建议先不封装，如后面不满足需求时再封装，就像将字段搬移到其他类前，先进行字段自我封装一样。 对象取代数值、对象取代数组 值对象改为引用对象、引用改为值 两个类之间的双向关联，就像双向绑定一样，在js 动态语言实现更方便，无需提前说明字段，直接添加。用过 layaAir 游戏里面，物理引擎body 和现实画面物体的坐标进行帧循环同步 配置常量代替魔法数字 封装字段，类里面的字段应该设置为private，并提供set/get 方法给外部访问。否则，字段被外部操作，类却不知道（因为直接访问字段）。这样做把数据和行为分开了。 数据类取代记录，把数据归类，抽到类中，该类没有只有数据，没有行为 类型码的取代，如 switch/case 类取代类型码 子类取代类型码 state/strategy（设计模式） 取代类型码 重新组织数据的方法，其中4、5、6、7 比较常用，5、7对数据归类，抽取配置是必须要求的。对类型码的处理，等涉及了再熟悉。 简化条件表达式 分解、合并条件表达式，比如if 成立条件判断涉及多种情况，但是为一个目的 123456789101112131415# 分解条件表达式// 是否不是夏天if(date.before(SUMMER_START) || date.after(SUMMER_END))&#123; ......&#125;// 可以抽取条件判断为一个函数，签名为 notSummer(date)# 合并条件表达式double disabilityAmount()&#123; if(xx1) return 0; if(xx2) return 0; if(xx3) return 0;&#125;// 可以合并上面判断逻辑 合并重复的条件片段，比如if/else 内都含一段逻辑，可以提取至外面 break/return 代替控制标记，结构化编程原则指明，每一个子程序只能有一个入口一个出口（单一入口原则），选择加入控制标记，降低可读性。因此编程语言提供，break/continue/return 卫语句取代嵌套条件表达式 多态取代条件表达式 引入null 对象 简化函数调用 修改函数名，可能一开始没法取一个适当的名字 添加、移除参数 将查询、修改函数分离，每个函数只做一件事 保持对象完整，将要传递的多个参数替换成一个对象，也是引入参数对象 以工厂函数代替构造函数 123456789101112131415161718192021222324252627282930313233343536373839class Employee&#123; private int _type; static final int ENGINEER = 0; static final int SALESMAN = 0; static final int MANAGER = 0; Employee(int type)&#123; _type = type; &#125;&#125;# 改为 工厂函数static Employee create(int type)&#123; return new Employee(type);&#125;# 更近一步 // 应该吧 engine/salesman/mannager 抽出成子类static Employee create(int type)&#123; switch(type)&#123; case ENGINEER: return new Engineer(); case SALESMAN: return new Salesman(); case MANAGER: return new Mannager(); default: throw new IllegalArgumentException("xx"); &#125;&#125;# 简化switchstatic Employee create(String name)&#123; try&#123; return (Employee)Class.forName(name).newInstance(); &#125;catch(Exception e)&#123; throw new IllegalArgumentException("xxx"); &#125;&#125; 封装向下转型，java 5 模板机制，模板类？ 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>改善代码</category>
        <category>重构</category>
      </categories>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[k-means]]></title>
    <url>%2F2018%2F11%2F19%2Fk-means%2F</url>
    <content type="text"><![CDATA[k-means 聚类k-means聚类是无监督学习，训练数据集都是未添标签的(不知类别)。就连数据集最终要分成几类都是不知道的。聚类和分类的不同是，后者必须对分类的目标事物必须是已知的。 聚类算法是根据样本之间的距离（相似度）来分类的，判断是否属于同一个簇。常见的计算距离的算法有欧式距离，曼哈顿距离和余弦相似性距离等。其中欧式距离，在二维平面上就是两点距离公式。 应用假设有如下数据集，现在要用k-means 聚类把它进行分类123456789101112131415161.658985 4.285136-3.453687 3.4243214.838138 -1.151539-5.379713 -3.3621040.972564 2.924086-3.567919 1.5316110.450614 -3.302219-3.487105 -1.7244322.668759 1.594842-3.156485 3.1911373.165506 -3.999838-2.786837 -3.0993544.208187 2.984927-2.123337 2.9433660.704199 -0.479481............ k-means的算法核心是 把上面数据放在 二维矩阵dataSet 指定想把数据集分为 k 类 随机生成 k个质心$A_1(x_1, y_1)$,$A_2(x_2, y_2)$….$A_n(x_n, y_n)$，生成方法是选出矩阵第一列$min_1$, $max_1$，选出第二列$min_2$,$max_2$，在$[min_1$,$max_1]$ 随机产生$x_1$，在[$min_2$,$max_2]$生成$y_1$，得出$A_1(x_1, y_1)$。同理生成其他质心 遍历全部数据点，离哪个质心距离最近，数据就归为那类。建立一个二维矩阵存储各个数据分类情况和误差（离质心距离） 更新质心：计算每个类所有点的均值作为质心 重新遍历全部数据点，若没有一个数据归类改变isChange = false，则聚类结束 最后聚类结束之后的结果 二分 k-means二分k-means 是对k-meas 的改进 参考文章 K-Means（K-均值）聚类算法 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>数据处理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>k-means</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性回归]]></title>
    <url>%2F2018%2F11%2F17%2F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[线性回归回归是用来预测数值型的目标值，数据集是连续型的，用线性回归找到最佳拟合直线。从一大堆数据中求出回归方程是我们的任务。假设一个样本数据放在矩阵$x_1$中，$y_1$是结果，回归系数放在向量$w$ 中。 $x_1 = \left[ \begin{matrix} 1 \\\ 4 \\\ 3 \\\ 3\\ \end{matrix} \right]$，$w = \left[ \begin{matrix} w_0 \\\ w_1 \\\ w_2 \\\ w_3\\ \end{matrix} \right]$ 则$y_1 - x_1^Tw$ 就是在该样本的预测误差，即拟合值和实际值的误差。在使得全部数据集误差最小的情况下求出系数，防止误差的正负相互抵消，利用平方的形式求和。可得误差表达式$\sum_{i=1}^m (y_i - x_i^Tw)^2$，我们称这个函数为损失函数（loss function）。这种求回归方程的方法称最小二乘法。 求损失函数最值欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>数据处理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Logistic回归]]></title>
    <url>%2F2018%2F11%2F13%2Flogistic%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[Logistic回归回归是对一些数据点进行拟合，该拟合过程称为回归，这样的思想是用来做预测的。为什么能用来分类呢？假设有一个这样的函数，名称为Sigmoid$$f(z) = {1 \over 1 + e^{-z}}$$ 该函数显然随着z 增大$ f(z)$的值逼于1; 随着z的减小，$f(z)$等于 0。 如果把自变量Z的值范围扩大到，如-20 到 20， f(z)就是一条突变的0到1的很陡曲线。 假设现在有如下数据集(含特征和类别)123456特征1 x0 特征2 x1 类别-0.017612 14.053064 0-1.395634 4.662541 1-0.752157 6.538620 0-1.322371 7.152853 00.423363 11.054677 0 假设 f(z) 的自变量 $z = w_0x_0 + w_1x_1$，将 z 代入 f(z)，该z使得f(z)产生突变， 即可得到在0 &lt; f(z) &lt; 1 规定 f(z) &lt; 0.5, 该数据归为第一类 规定 0.5 &lt; f(z), 该数据归为第二类 所以求 $w_0$,$w_1$ 就是实现这一思想核心！ 梯度假设$z=f(x, y)$三维图像类似一座山峰的表面图形，像一顶帽子的图像。假设取山峰上一点$A(x_0, y_0, z_0)$，接下你想朝一个最陡峭的方向往上爬。该最陡峭的方向即为 A 点的梯度，所以梯度是个向量 梯度求法举例，假设有函数$z=f(x,y)$，梯度公式为 假设$z = 2x^2 + y^2$，则$\nabla f(x,y) = (4x, 2y)$，求在 $A(x_0, y_0, z_0)$的梯度为，将$x_0$， $y_0$ 带入梯度向量。A的 梯度为 $(4x_0, 2y_0)$ 还有另外一个移动步长k的概念，从A点沿着梯度方向$\nabla f(x,y)$(最陡峭方向) 爬一定的长度，就到了新的一个点A1,$A_1(x, y)=(x_0, y_0)+k(4x_0, 2y_0)$。再按照该方法就可以到新的点A2，这样一直爬下去A3, A4…..An就爬到了最高点An 梯度法得W关于用梯度法求解系数w 的推导，请看这篇理解 logistic 回归。文中最后得出W和数据特征X，和类别Y(0或者1)的迭代关系式。 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>数据处理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Logistic回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[朴素贝叶斯]]></title>
    <url>%2F2018%2F11%2F11%2F%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%2F</url>
    <content type="text"><![CDATA[朴素贝叶斯朴素贝叶斯是分类算法，一个新数据x出现，是类a的概率为$p(a/x)$，属于类b概率$p(b/x)$ 若$p(a/x) &gt; p(b/x)$，则x归为类a 若$p(a/x) &lt; P(b/x)$，则为类b 要直接比较 $p(a/x)$， $p(b/x)$ 的大小是很难的，我们可借助条件概率进行转化。先理解什么是条件概率，$$p(a/x) = {p(a,x) \over p(x)} $$ 这样就可以得乘法公式，$$p(a,x) = p(a/x)p(x)$$ 再把$p(a/x)$进行转换可得，$$p(a/x) = {p(a,x) \over p(x)} = {p(x,a) \over p(x)} = {p(x/a)p(a) \over p(x)}$$ 因此比较就变成了$$p(a/x) = {p(x/a)p(a) \over p(x)}$$$$p(b/x) = {p(x/b)p(b) \over p(x)}$$ 要比较他们的大小，就是计算出 $p(a)$，类别a出现的概率 $p(b)$，类别b出现的概率 $p(x/a)$，类别a出现时样本x出现的概率 $p(x/b)$，类别b出现时样本x出现的概率 应用接下来用朴素贝叶斯在文本分类，屏蔽社区留言板的侮辱性言论的应用作为例子，解释上面四个概率的求法。假设数据集如下123456789101112# 言论集postingList = [[&apos;my&apos;, &apos;dog&apos;, &apos;has&apos;, &apos;flea&apos;, &apos;problems&apos;, &apos;help&apos;, &apos;please&apos;], [&apos;maybe&apos;, &apos;not&apos;, &apos;take&apos;, &apos;him&apos;, &apos;to&apos;, &apos;dog&apos;, &apos;park&apos;, &apos;stupid&apos;],[&apos;my&apos;, &apos;dalmation&apos;, &apos;is&apos;, &apos;so&apos;, &apos;cute&apos;, &apos;I&apos;, &apos;love&apos;, &apos;him&apos;],[&apos;stop&apos;, &apos;posting&apos;, &apos;stupid&apos;, &apos;worthless&apos;, &apos;garbage&apos;],[&apos;mr&apos;, &apos;licks&apos;, &apos;ate&apos;, &apos;my&apos;, &apos;steak&apos;, &apos;how&apos;, &apos;to&apos;, &apos;stop&apos;, &apos;him&apos;],[&apos;quit&apos;, &apos;buying&apos;, &apos;worthless&apos;, &apos;dog&apos;, &apos;food&apos;, &apos;stupid&apos;]]# 1代表侮辱性言论，0 非侮辱性classVec = [0, 1, 0, 1, 0, 1] 要判断一个样本数据是否侮辱性言论，先统计全部言论去重之后的词汇，再得出每条言论基于全部词汇的词频矩阵12345678910词汇集= [&apos;word1&apos;,&apos;word2&apos;,‘word3’..,&apos;wordn&apos;]# 第一列的2代表word1在言论1中出现2次言论1： [2, 0, 1, ....,4]言论2： [3, 2, 0, ....,2] ......言论n： [0, 2, 2, ....,0] 总侮辱言论：[45, 122, 232, 0,.....,90]总非侮辱言论：[123, 23, 23, 2,.....,23] 假设a类别为侮辱性言论，b类别为非侮辱性言论，言论总数为N，a总数量n1，b总数量n2。此时可以求得， $p(a) = {n1 \over N}$ $p(b) = {n2 \over N}$ 至于$p(x/a)$，要求a类别出现时x样本出现的概率，x是由很多词汇构成的。朴素贝叶斯算法的朴素二字正是假设各个特征之间是相互独立的，即每个词汇的出现是不会相互影响的；并且认为每个特征同等重要。因此求得侮辱性言论出现时每个词汇出现的概率为12# n0=sum([45, 122, 232, 0,.....,90]),即侮辱性言论集中总词数[45, 122, 232, 0,.....,90]/n0 假设x样本包含词汇为 xword1,xword2,….xwordi…xwordn，侮辱性言论出现时对应词汇出现的概率为p(xword1)，p(xword2)，p(xwordi)…….p(xwordn)$$p(x/a) = p(xword1)p(xword2)…p(xwordi)…p(xwordn)$$ 同理可得$p(x/b)$，至以上四个概率都是已知量。这样就可以用朴素贝叶斯模型进行分类。要注意的是，防止有词汇概率为 0， 词汇计数初始值1，总词汇初始值2，即1[45, 122, 232, 0,.....,90]+1 / (n0+2) 防止$p(xword1)p(xword2)…p(xwordi)…p(xwordn)=0$，采用自然对数 参考文献 基于概率论的分类方法：朴素贝叶斯 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>数据处理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>朴素贝叶斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树]]></title>
    <url>%2F2018%2F11%2F09%2F%E5%86%B3%E7%AD%96%E6%A0%91%2F</url>
    <content type="text"><![CDATA[决策树决策树是分类算法，一个未贴标签(未知类别)的新数据(含多个特征)，通过问多个问题（问题是：特征，答案：是或者否），最终问题问完，判断出新数据类别。问问题的流程基于决策树。 所以训练决策树的步骤一般是，先有已知类别的数据集、选择特征问问题生成决策树、测试决策树。决策树模型生成之后就可以用于分类没贴标签的数据集。 要理解决策树算法，首先要知道熵的概念，是信息论里面的知识，用来形容信息的混乱程度。信息越有序则熵值越低，越混乱熵值越大。熵的计算公式，其中p(x) 代表类别x在信息整体中出现的概率$$H=-\sum_{i=1}^np(x_i)\log_2p(x_i)$$ 比如计算下面数据的熵值123456# yes 代表是鱼类，no 代表不是鱼1, 1, &apos;yes&apos;1, 1, &apos;yes&apos;1, 0, &apos;no&apos;0, 1, &apos;no&apos;0, 1, &apos;no&apos; 上面信息整体中有鱼类x1，非鱼类x2，出现的概率分别为2/5，3/5，所以上面的信息熵为1- 2/5log(2/5) - 3/5(log3/5) 应用用决策树算法来判断生物是否鱼 收集数据 1234567891011121314151617特征1（不浮出水面是否能活） 特征2（是否有脚蹼） 类别(是否鱼)yes yes yesyes yes yesyes no nono yes nono yes no# 变成向量的形式： dataSet = [ [1, 1, 'yes'], [1, 1, 'yes'], [1, 0, 'no'], [0, 1, 'no'], [0, 1, 'no']]# labels 存储的是特征，即决策树的问题labels = ['no surfacing', 'flippers'] 分析数据：这里的数据集不是连续的，都是0,1 离散数据，这步可以省略 构造算法，选择labels 中哪个特征来问题呢，全部特征集合labels存储，逐一尝试，计算分类前后香农熵，选取信息增益(熵差)最大的特征x，划分后的子集去除特征x, 集合labels去除特征x。就这样一直递归下去，直到每个子集的只有一种类别，即信息熵为0 假设我们在特征1和特征2选特征1来分类，即问一个问题(此新数据不浮出能活吗)，安照答案(即特征值yes no )得到分类，并计算该数据集的香农商。分类后 由特征1分类，子集去掉特征1，计算数据集香农熵12345#分类前香农熵： - 2/5log(2/5) - 3/5(log3/5) #分类后香农熵,- 3/5*(2/3log(2/3)+1/3log(2/3)) - 2/5*(1log1) 分类后香农熵，3/5 表示该子集占全集，2/3表示 yes在子集占比。若子集类别一致，香农熵为 0 最后形成的决策树{&#39;no surfacing&#39;: {0: &#39;no&#39;, 1: {&#39;flippers&#39;: {0: &#39;no&#39;, 1: &#39;yes&#39;}}}} 参考文献 决策树 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>数据处理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KNN算法]]></title>
    <url>%2F2018%2F11%2F07%2FK-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[K-近邻算法KNN用于分类，先有已知类别的数据集，输入一个样本，利用K-近邻算法得出该样本的类别， 一个样本包括特征、类别等数据。KNN 程序代码戳这里 kNN原理 带有标签(类别)样本数据集，包含样本特征 输入没有标签的新数据，将新数据和样本集数据对应的特征进行比较 计算新数据和样本集的欧式距离 取出最小的前k个，取出这k个样本中出现次数最多的类别，作为新数据的类别标签 应用优化约会网站的配对效果，数据样本包括:前三个是特征，最后一个是类别12345飞行常客历程数 玩游戏占时间比 每周冰淇淋消费公升数 类别40920 8.326976 0.953952 3 14488 7.153469 1.673904 226052 1.441871 0.805124 1..... 其中类别 1不喜欢的人 2魅力一般的人 3极具魅力的人，最终输入新数据，用 K-近邻 判断其类别。 KNN的使用过程如下， 收集数据：提供上面格式的文本数据 准备数据：python解析文本，返回一个矩阵A包含样本集特征，一个类别矩阵B 分析数据：Matplotlib画二维散点图，剔除一些点 训练数据：此步骤不适合K-近邻算法，和测试工作一样 测试算法：取数据集(已知类别)一些点，测试是否分类正确，否，标记一个错误 使用算法：产生简单命令行程序，输入一个新数据特征，输出其类别 分析数据时取特征1、特征2为x轴，y轴，将各个样本数据在图中显示。不同类别用不同颜色，以便观察是否适用KNN 。效果如下图， 计算样本距离前，可以先把各个特征的数据进行归一化，即把该特征的值固定在一个范围里。归一化可以消除特征之间数据量级不同导致的影响，比如上面的飞行常客历程数上万的数值，而玩游戏占时间比只是几十，两者相差太大；同时归一化可以保证程序运行收敛加快。 一个样本相当矩阵A的一行，计算距离可以先把各个特征（即A的各个列）归一化到[0, 1]的范围，采用线性函数转换的方法。做法是取出该列min、max，把x归一化后y为 y = (x-min)/(max-min) 归一化的其他方法还有对数函数转换，反余切函数转换 参考文章 k-近邻算法训练数据来源 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>数据处理</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>K-近邻</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目合作总结]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[回想自己和其他开发人员团队合作中，有过各种各样的问题。比如 哪些明明是简单的需求，却要花很多时间，还不能保证稳定。 平时花费很多时间去学习，看似很努力却得不到想要的回报 需求变得越来越难写 开发的效率没有提高，还是用以前一贯的思路 后来发现这是自己没有好的工作习惯，因此总结了一下，引起重视 工作原则 敬畏之心，每个人应该对项目的规范怀有敬畏之心，否则不仅不能因为合作提高效率，还会引发更多麻烦。比如遵循git flow 流程，发布项目必须经历内网、外测、正式服，还有其他一系列团队约定的开发规范。 分清需求优先级，分清需求的轻重缓急，就不会弄得自己手忙脚乱。 空杯心态，团队合作免不了交流沟通，如理解需求、约定代码结构等，我们应保存空杯心态，平静表达自己的观点，谦虚听取大家的意见，最终做合理的决定。比如 要在其他同事基础之上添加需求，但他的设计不合理或者不满足 感觉产品需求不合理，或者无法实现 改善代码，当发现需求越来越难以实现，想添加新需求却感到困难，不妨试试重构现有代码。当然你必须学习重构技术 p/pc 平衡 ，一个养鸡的农夫不给鸡喂食就得不到更多的鸡蛋，杀鸡取卵更是连得到鸡蛋的资本都失去了。产出和产能必须平衡提示我们 想提高效率，要持续关注新技术，改善思路 必须坚持锻炼，保持开发人员健康身体 怎样接触新技术结合自己学习经历和接触到的有经验开发者，谈谈自己是怎样学习新技术的。比如你接触小程序 官方文档术语规范、内容齐全，看完都得花一段时间，不宜入门。可以看优秀的入门文章（但其他时候还是不怎么建议，xx入门除外），比如这篇没有html/css 基础的小程序入门 结合实际、总结、细看官方文档，可以和其他语言进行对比 持续关注小程序社区，解决遇到的难题 解决状态管理、跨页通信问题 编写css 花费大量时间 比如，你想入门less 看官方文档挺费劲，先看入门文章大概就清楚了 再结合实战，细学 更深入的，抓住框架设计原理，学会画架构图、流程图、类图、思维导图，有助自己尽快抓住技术核心。别总是停留在语言语法应用层面，语言用来完成业务的语法或有不同。没有必要那么在意，这个只是设计者的习惯。学东西，最忌一直零散，浮于表面，那就是一直依赖搜索解决问题的搬运工。 分析设计原理的优劣，培养技术选型能力， 实现一个业务问题，分析技术解决方案的优劣，设计是否符合扩展性（完善代码，设计模式） 推动团队在团队开发中，一开始可能不知道那里阻碍了你，哪个部分你的效率还可以提高。但是可以列出花费时间最多的环节，并想办法优化，就这样持续迭代。比如小程序开发中（按时间多少排序） css 编写页面 沟通：联调后端API，理解需求 设计代码结构，实现 这时我就会查找利用less 提高编写效率，利用 postman/mock 等联调工具，去社区寻找别人的解决方案。 其他效率工具总结了一些提高工作效率的工具，有些是来自同事分享 命令行启动软件，把软件启动的快捷方式复制至同一目录，并添加至环境变量，在不用碰鼠标，不用切换当前窗口的情况下按win+R，通过输入软件名称（当然可以自定义）启动应用。 查找软件 everything，可以搜索计算机所有盘符，进行查找，秒速 截图软件 Snipaste，所截图位于窗口最上方，实现代码对比，达到分屏效果 打开搜索 Wox，不用切换窗口进行搜索，按Alt+ space –&gt; g xxxx，如在编辑器页面迅速调动搜索 便签，计划提醒 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>工作总结</category>
        <category>效率</category>
      </categories>
      <tags>
        <tag>工作原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware 安装centos6.5 虚拟机]]></title>
    <url>%2F2018%2F10%2F20%2Fvmware%20%E5%AE%89%E8%A3%85centos%20%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[在本地安装虚拟机，并用secureCRT 连接可以搭建测试环境，提高开发效率。 安装在vmware 安装centos6.5， 可以选择最小化安装，这种模式好像没有鼠标，但是可以利用vmware 完成粘贴复制，连接好secureCRT后就没影响了。安装了desktop 版本，也可以删除桌面。 vmware centos6.5 bin DVD1 secureCRT 连接安装 secureCRT，提取码：q9wb，设置好自己习惯的操作方式，如选中复制，右键粘贴，背景色等。连接 生成私秘钥，Tools–&gt;Create Public Key –&gt; key type: RSA —&gt; OpenSSH Key format centos 生成私秘钥文件 12# root 用户，/root/.ssh 下生成ssh-keygen -t rsa 公钥复制到 /root/.ssh/authorized_keys 文件中，必须是这个文件名 centos 查看ip 地址 1234567891011121314151617# 设置网卡随系统启动生效cd /etc/sysconfig/network-scriptsls //查看网卡文件 如ifcfg-eth0vim ifcfg-eth0 //修改为 ONBOOT=yes# 必须 root用户， 重启网卡service network restart# 是否生效ping www.baidu.com // 没问题# 查看网卡 ip ifconfig // 如，inet addr:192.168.36.100# 该ip, 和主机是同一个子网内，# 在cmd 命令行 ipconfig 查看到 VMware Network Adapter VMnet1# 因为vmware 默认配置一个网卡ANT 连接方式，没有的话，可能是在网络共享中心--&gt; 更改适配器设置 禁用了 连接，File–&gt; Quick Connect ，把publicKey 放到第一位置，连接成功 对网络概念不熟悉可以，参考理解 配置静态ip上面虚拟机的ip 下次开机可能会发生改变，比如你在vmware 再建立一台虚拟机发现ip 变了。这种情况可以把 ip配置成静态ip vmware 给该虚拟配置网卡（默认就是一张网卡NAT 方式，也可以） VMware –&gt;编辑–&gt;虚拟网络编辑器–&gt; NAT –&gt; 取消dhcp 动态分配 VMware –&gt;编辑–&gt;虚拟网络编辑器–&gt; NAT –&gt; NAT 设置，查看网关 配置centos /etc/sysconfig/network-scripts/ifxxx 网卡 12345678910111213# device 和网卡名一样# 添加最后5 项就可以了，改成你虚拟机相应ipDEVICE=eth0HWADDR=00:0C:29:32:46:15TYPE=EthernetONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticIPADDR=192.168.36.100NETMASK=255.255.255.0GATEWAY=192.168.36.2DNS1=192.168.36.2 # 和网关一样 root 重启 网卡服务, service network restart ifconfig 查看是否为自己设置的ip 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>基础</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vmware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序 自定义组件]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[小程序中如果一个页面UI太过复杂，亦或者某个UI组件复用次数多，可以考虑抽取出自定组件。抽离组件可以 分而治之，使代码结构更清晰，也是重构的目的。 复用，使逻辑出现在唯一出 自定义组件页面中的网络头像有加载过程，可以在加载过程中给图像一个占位图。而这复用率很高，可以考虑抽取组件 头像图片未加载成功之前显示占位图，利用bindload方法 123456789101112131415161718192021&lt;!--profile.wxml--&gt;&lt;view class='v-h-center'&gt; &lt;image class="&#123;&#123;isFinishLoad ?'':'before-load'&#125;&#125;" src='&#123;&#123;imgSrc&#125;&#125;' bindload='finishLoad' /&gt; &lt;/view&gt;&lt;!--profile.js--&gt;finishLoad: function()&#123; this.setData(&#123; isFinishLoad: true &#125;);&#125;&lt;!--profile.wxss--&gt;.before-load &#123; width: 64rpx; height: 64rpx; border-radius: 50%; border: 1rpx solid #a7a7a7; background-color: #EEE;&#125; 点击头象，通知触发父组件事件 1234567// 引用组件的页面.wxml&lt;profile bindXXX='xxx' imgSrc='&#123;&#123;xxx&#125;&#125;' data-xx="&#123;&#123;xxx&#125;&#125;" /&gt;&lt;!--profile.js--&gt;_event: function(e)&#123; this.triggerEvent('XXX') &#125; 相册授权小程序中将图片或者视频，下载后保存到用户本地相册需要用户授权。若用户首次拒绝授权，再次下载时，得再次弹出询问授权按钮，否则图片无法下载。 保存到相册，首次拒绝授权，第二次保存失败，再次询问 wx.openSetting1234567891011121314151617181920212223242526272829wx.saveVideoToPhotosAlbum(&#123; filePath: res.tempFilePath, success: res =&gt; &#123; this.showMsg('视频已保存到相册~~'); &#125;, fail: res =&gt; &#123; this.getPhotoAuthorize(); &#125;&#125;);getPhotoAuthorize: function () &#123; wx.showModal(&#123; title: '提示', confirmText: '去授权', content: '授权后才能保存到相册噢', success: res =&gt; &#123; if (res.confirm) &#123; console.log('用户点击授权') wx.openSetting(&#123; success: function (res) &#123; if (!res.authSetting["scope.writePhotosAlbum"]) &#123; console.log('重新授权成功') &#125; &#125; &#125;) &#125; &#125; &#125;)&#125; 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>web</category>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>自定义组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序笔记]]></title>
    <url>%2F2018%2F10%2F16%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近接触了一段时间小程序，记录了在开发过程中的一些结论 小程序开发 小程序前后端交互过程 wx.login()获得code，传给后台服务器 后台服务器请微信服务器请求，返回openId/sessionKey（用于获取用户已授权的其他数据，如运动步数），后台把openId/sessionKey存储在session，前端header里就会得到一个set-cookie 小程序前端要缓存（setStorageSync），每次请求携带cookie，后台就可以判断是哪个用户，这个过程要自己实现（和浏览器不一样） 用户授权过程 授权窗口按确定1234567&lt;button open-type=&apos;getUserInfo&apos; bindgetuserinfo=&quot;getUserInfo&quot;&gt; &lt;text&gt;微信授权&lt;/text&gt;&lt;/button&gt;getUserInfo: function(res) &#123; xxxx&#125; 改变小程序每个页面或者单页面的背景色 在app或者xx.wxss 加入，page 前面不用点123page &#123; background-color: #f4f4f4;&#125; wx：key 在渲染中的作用 当指定wx:key时，列表改变时（包括内容和顺序），渲染时只是重新排序各组件，而不用重新创建 key 要求唯一 key 对性能提高有好处 小程序异步问题，首页onLoad() 抢在app.js 的login 方法之前执行 封装代码方法，函数回调12345678910111213141516171819function waitFlag(signalOrigin, flag, status) &#123; return new Promise(function(resolve, reject) &#123; let i = 0 let check = function() &#123; if (!!signalOrigin[flag] === !!status) &#123; resolve() &#125; else if (i++ &gt; 1000) &#123; reject() &#125; else &#123; setTimeout(check, 50) &#125; &#125; check() &#125;)&#125;waitFlag.waitFlag(app.globalData, 'hasGet', true).then(() =&gt; &#123; xxxxxx&#125;) 轮播图，图片，高度自适应(提前知道图片的WH，赋值给swiper) 图片设置为 懒加载，否则加载过多图片手机迅速发烫 点击图片放大功能 视频图像得先下载，再保存到相册 给图片添加水印，或者二维码（建议后端来做：一条linux命令搞定） cavans 画图，加字 cavans 利用绝对定位隐藏，画图是visable: true visable: false，导出图片到相册 ios 下video 出问题，无法部分视频 设置 video 的custom-cache=”false“ e.currentTarget.dataset/e.Target.dataset 的区别 图片加载时的占位图 视频不在可视范围，停止播放12345678910111213ready() &#123; // 在自定义组件内，一定要加上后面参数 this this.videoContext = wx.createVideoContext('swiperVideo', this) if (this.videoContext) &#123; this.createIntersectionObserver().relativeToViewport(&#123; top: -100, bottom: -100 &#125;).observe('.swiper-video', (res) =&gt; &#123; this.videoContext.pause(); &#125;); &#125;&#125; 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>web</category>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 入门]]></title>
    <url>%2F2018%2F10%2F16%2Flinux%20%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[linux 是后端项目运行的环境，很多开发者都是在windows 下编写代码，后部署到linux 上运行。所以linux 是很重要的基础，是开发人员需要了解的。学习资料参考 建议用centos—下载 bin-DVD1 鸟哥私房菜第三版 安装可参考 linux 起源 Unix、GUN、Linux起源， 追求：先求有且能运行，再求进一步改善 linux 的版本是指内核版本。linux 版本分为两类，一种使用RPM 方式安装软件系统，包括Red Hat、Fedora、SuSE、CentOS; 另外一种 dpkg 方式安装软件，包括 Debian、Ubuntu、B2D linux 多用户、多任务，与Windows系统不同。文件的属性可分为可读，可写，可执行，属性可分为文件拥有者、文件所属用户组、其他非拥有者与用户组者。 缺点，没有特定的支持厂商，游戏支持度不够、专业软件的支持度不够（如：绘图软件） 文件权限 linux 是多人多任务的， 用户的配置信息在etc/xx 下面。进入文件夹要x 权限，r 只能查看文件夹的文件列表 linux 下面全部都是文件，文件没有后缀，也有一些常见的 .sh、 .tar.gz 只是为了启动见名知义 linux 各个目录存放的规范 安装软件一般放在，usr/local 或者 opt 目录规范和操作 查看 环境变量，相对、绝对目录 echo PATH 执行当前目录的命令时，加入./ 目录与文件常用命令 touch/mkdir cat vim mv cp/cp -r scp rm -rf xx rm -rf xx/* 目录、文件权限，umask, 可以通过umask 提前设定要创建目录的权限值，文件默认权限 666，目录默认权限 777 12345umask umask -Sumask 022 // 022 的值解释# 022 代表0 相对默认权限减去 0 + 0 + 0 权限# 2 代表减去 0 + 2 + 0 写权限没有了 修改用户权限—chmod/chown/chgrp 添加用户、组、other 文件的查找 which 在当前环境变量下路径查找 whereis 寻找特定文件，速度快 find 硬盘查找，速度慢 文件的压缩与打包压缩，文件用0，1 存储后还有很多空间未填满或者有很多重复数据，将这些空间填满或者减少空间就是压缩技术的目的。 比如数字1，由于 1byte = 8bits，其他7bits 默认为0，第一位为1 比如重复有100 个1, 并不需要真正存储100个1，标记100个1，减少空间 linux 的命令只能压缩一个文件，所以先把文件打包在进行压缩。最常用打包、压缩命令： 压缩：gzip -v 文件名 12345-c ：将压缩的数据输出到萤幕上，可透过数据流重导向来处理；-d ：解压缩的参数；-t ：可以用来检验一个压缩档的一致性～看看文件有无错误；-v ：可以显示出原文件/压缩文件的压缩比等资讯；-# ：压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！默认是 -6 打包：tar 123tar -zcv -f filename.tar.gz 要被压缩的文件或目录名称tar -zxv -f filename.tar.gz -C 想解压到的目录tar -ztv -f filename.tar.gz 查看文件 tar.gz 先打包再压缩的文件 linux 正确的关机方法1234567# 机器状态 谁在线who # 关机，重启shutdown -h now // 时间参数务必加，否则跳到单人维护的登入情况reboot sync //把内存数据写到硬盘，上面两个命令包含了这个 安装软件在linux 下安装软件是必须掌握的技能，安装方式一般有yum install，直接安装rmp包，编译安装源码包等方式。 yum install 原理，yum install 安装rpm 软件包 123456789101112131415161718192021222324252627282930# 列出可用的 rpm 包yum list | grep 包名yum rearch 包名# 安装yum install [y] xx // 回答所有的问题 yes# 删除yum remove xx# yum 其他常用命令ls /etc/yum.repos.d //yum 仓库的配置文件&lt;!-- 比如卸载桌面 --&gt;yum grouplist | grep Desktopyum groupremove -y Desktop// 修改 /etc/inittab 里面的 为3，不是5 (x11)# Default runlevel. The runlevels used are:# 0 - halt (Do NOT set initdefault to this)# 1 - Single user mode# 2 - Multiuser, without NFS (The same as 3, if you do not have networking)# 3 - Full multiuser mode# 4 - unused# 5 - X11# 6 - reboot (Do NOT set initdefault to this)# id:3:initdefault: 直接安装 rpm 包 123456789101112131415161718# 查询是否安装rpm -q 包名 # 安装rpm -ivh 包文件# 卸载rpm -e 包名# 查询 rpm包，a--all q--queryrpm -aq | grep rpm # rpm 其他常用命令rpm -Uvh 包名 // 包升级rpm -qi 包名 // 查询指定包信息rpm -ql 包名 // 列出包安装文件rpm -qf 文件绝对路径 //查看该文件由那个包安装 源码编译安装，比如 centos 安装 git 工具，源码下载 1234567891011121314151617181920# 解压 .tar.xz 或者 .tar.gztar -Jxvf git-2.9.5.xz -C .# 源码安装 先配置安装目录，有助后期卸载、迁移./configure prefix=/usr/local/git-2.9.5# 编译 make# 安装 一般两个命令一起写 make &amp;&amp; make install make install # 一般再设置一个git 软连接，安装软件的习惯ln -s git-2.9.5 git # 添加环境变量vim /etc/profileexport PATH=/usr/local/git/bin:$PATHsource /etc/profile 文本处理技巧在linux 编辑文本是很常见的操作，比如修改配置文件、查看项目日志、处理文件数据、编写shell script 等等，这些都要用文本处理。 编写文本一般用vim 编辑器 查看文本内容的几种方法 12345678910111213# 打印文件所有内cat filename 容# 跟踪打印输出文件tailf xx.log# 打印文件最后10行的数据tail -n 10 # 打印文件第10行开始以后的内容tail -n +10 # 打印前10的内容head -n 10 grep 用于文本内容的查找，文本三剑客之一，常配合管道使用 12345ls -lh xx | grep xxps aux | grep mysqlnetstat -tlnp | grep redis sed 用于文本内容的编辑，常用于文本替换 12345678910111213141516# sed [option] 'command' filename# option-n：使用安静(silent)模式。 在一般sed的用法中，所有来自stdin的数据一般都会被列出到终端上。 但如果加上-n参数后，则只有经过sed特殊处理的那一行(或者动作)才会被列出来。-e：直接在命令列模式上进行sed的动作编辑。-i：直接修改读取的文件内容，而不是输出到终端。直接修改真实文本# commanda：追加，a的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)i：插入，i的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)d：以行为单位的删除c：以行为单位的替换，c的后面可以接字串s：在行中搜寻并替换p：以行为单位的显示，通常p会与参数sed -n一起运行 awk 用于对文本进行分析，当要对处理的数据生成报告，或者数据是按照列进行处理时，使用awk 更方便 12345# 输出第一列 awk '&#123;print $0&#125;' demo.txt# 用冒号分割每行文本 awk -F ':' '&#123; print $1 &#125;' demo.txt 数据流重定向 1234567891011121314151617181920# 将ls -l 输出的信息重定向到 /data/tmp/rootfilels -l &gt; /data/tmp/rootfile# 追加ls-l &gt;&gt; /data/tmp/rootfile# cat 创建文件cat &gt; catfile xxxx按ctrl+d 离开# 输入 eof 结束cat &gt; catfile &lt;&lt; 'eof'xxxxeof # 用文件代替手动输入cat &gt; catfile &lt; filename 查看进程和端口号 ps aux 查看运行程序 12345678910111213# a 不与 terminal 有关的所有 process # u 有效使用者 (effective user) 相关的 process # x 通常与 a 这个参数一起使用，可列出较完整资讯。ps aux# USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.0 19232 1508 ? Ss 18:55 0:03 /sbin/init# user process 属于的用户 # PID 识别码# %CPU 使用的CPU 资源占比# %MEM 内存百分比 netstat -tlnp 网络联机状态1234567891011# -a ：将目前系统上所有的连线、监听、Socket 数据都列出来# -t ：列出 tcp 网络封包的数据# -u ：列出 udp 网络封包的数据# -n ：不以程序的服务名称，以埠号 (port number) 来显示；# -l ：列出目前正在网络监听 (listen) 的服务；# -p ：列出该网络服务的程序 PID netstat -tlnp# Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 1996/nginx linux 启动流程理解linux启动时都做什么可以完成一些设置 比如完成 卸载桌面 123456789101112131415&lt;!-- 比如下载桌面 --&gt;yum grouplist | grep Desktopyum groupremove -y Desktop// 修改 /etc/inittab 里面的 为3，不是5 (x11)，如下：# Default runlevel. The runlevels used are:# 0 - halt (Do NOT set initdefault to this)# 1 - Single user mode# 2 - Multiuser, without NFS (The same as 3, if you do not have networking)# 3 - Full multiuser mode# 4 - unused# 5 - X11# 6 - reboot (Do NOT set initdefault to this)# id:3:initdefault: 设置服务在开机时自启动 12345# 在 /etc/rc.d/rc.local 添加 /etc/init.d/mysql start/etc/init.d/redis start/etc/init.d/php7-fpm start 同步网络时间12345678910111213141516# 安装ntpdate工具yum -y install ntp ntpdate# 设置系统时间与网络时间同步ntpdate cn.pool.ntp.org# 将系统时间写入硬件时间hwclock --systohc# 或者写到crontab 定时同步网络时间vim /etc/crontabPATH=/usr/sbin:/sbinexport PATH# 每分钟同步一次* * * * * ntpdate cn.pool.ntp.org &amp;&amp; hwclock --systohc 用户群主概念、账号管理 UID/GID，比如用户 lcs，在/etc/passwd 里面对应 lcs—UID 500 12345678910lcs:x:500:500:lcs:/home/lcs:/bin/bash&lt;!--各个字段含义：--&gt;1. lcs 名词2. x 口令，但是未显示，存在/etc/shadow3. 500 UID 0代表root，1-499 系统账号4. 500 GID5. lcs 用户信息说明栏6. /home/lcs 家目录 7. /bin/bash 给用户一个shell（bash） 和系统沟通 /etc/shadow 存放各用户密码 lcs 用户一登入就有一个初始群组lcs，lcs用户可以加入其它群组，加入这么多群组，创建新文件属于的群组是有效群组。 1234567891011&lt;!--组名和GID 对应--&gt;etc/grouproot:x:0:root1. root 群组名2. x 口令，未显示3. 0 GID4. root 该群组包含的用户，把lcs 加入会显示 root,lcs&lt;!--查看所属群组，第一个为有效群组，新文件所属群组--&gt;groups 可以切换lcs 用户的有效群组，涉及/etc/gshadow 扩充linux 根目录下面链接都可以完成扩容，计算机里面一个磁盘显示的是 /dev/sda，两个显示/dev/sdb，利用 fdisk对磁盘进行分区。理解 pv/vg/lv 对完成扩容有帮助 扩容–详细 扩容–简略 pv/vg/lv 概念理解123456/dev/sda1/dev/sda2 ...&lt;!-- 删除未知lv --&gt;vgreduce --removemissing [vgName]vgreduce --help 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>基础</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css 应用总结]]></title>
    <url>%2F2018%2F09%2F29%2Fcss%20%E5%BA%94%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[css伪类下面是自己使用过 伪类的几种场景 :last-child利用 css:last-child，实现循环四个元素，每一个元素都有底边框，但最后一个元素没有 注意 xx:last-child 找到有共同父节点样式为xx 的元素 再选定最后一个元素，该元素必须处在最后一位，且不能有其他不相关元素 比如复杂一点的形式：12345678910111213141516&lt;view&gt; &lt;view class="xx"&gt; &lt;text&gt;tt&lt;/text&gt; &lt;view class='yy'&gt;bb&lt;/view&gt; &lt;/view&gt; &lt;view class="xx"&gt; &lt;text&gt;tt&lt;/text&gt; &lt;view class='yy'&gt;bb&lt;/view&gt; &lt;/view&gt; &lt;view class="xx"&gt; &lt;text&gt;tt&lt;/text&gt; &lt;view class='yy'&gt;bb&lt;/view&gt; &lt;/view&gt;&lt;view&gt; css 代码应该这样写，12345678.xx .yy &#123; border: 1rpx solid #a7a7a7; border-width: 0 0 1rpx 0;&#125;.xx:last-child .yy &#123; border-width: 0;&#125; :nth-child(3n+2)利用 :nth-child(3n+2) 实现一个九宫格，用于展示图片。实现效果如下， 页面利用flex 布局，标签代码12345678&lt;view class='activities'&gt; &lt;view wx:for='&#123;&#123;starActivity&#125;&#125;' wx:key='postId' class='activity'&gt; &lt;image class='img-activity' src='xx' mode='aspectFill'&gt;&lt;/image&gt; &lt;xx&gt;&lt;/xx&gt; &lt;xx&gt;&lt;/xx&gt; &lt;/view&gt; &lt;/view&gt; 12345678910111213141516171819202122232425.activities &#123; width: 750rpx; padding: 30rpx; display: flex; flex-wrap: wrap; box-sizing: border-box;&#125;.activity &#123; width: 32%; height: 226rpx; margin-bottom: 15rpx; border: 1rpx solid #eee; box-sizing: border-box;&#125;.activity:nth-child(3n+2)&#123; margin-left: 15rpx; margin-right: 15rpx;&#125;.activity .img-activity&#123; width: 100%; height: 100%;&#125; 注意，img-activity 宽高设置为 100%，是指子元素 内容宽高==父元素 内容宽高，至于内容宽高指什么，是由box-sizing 值确定的（默认值 content-box)。 box-sizing: border-box 设置的width/height == 内容宽高 + padding + border box-sizing: content-box 设置的width/height == 内容宽高 在这里 activity 的内容宽高 = wh - (padding + border)， 所以img wh = 226rpx - 1rpx css 动画很多时候页面要添加动画，优化用户体验，可以利用css 语法支持实现。css 动画，不是瞬间变动，而是有个缓动效果，实现效果 实现效果，需要在点击后给元素添加一个样式修饰，下次点击又重现效果，类似 xx:hover。微信小程序元素（view/button）的 hover-class 刚好支持。实现如下123456789101112131415161718&lt;view class="action-sort-mount" hover-class='scale'&gt; &lt;image class="user-like img-WH" src="&#123;&#123;isLike?'/images/like_on.svg':'/images/like.svg'&#125;&#125;" /&gt; &lt;text class='text1'&gt;&#123;&#123;xx&#125;&#125;&lt;/text&gt;&lt;/view&gt;.scale &#123; animation: 0.3s myScale;&#125;@keyframes myScale &#123; from &#123; transform: scale(0.5, 0.5); &#125; to &#123; transform: scale(1, 1); &#125;&#125; transform: translate(x, y)利用 transform: translate(x, y) 实现一张 图片在底下一张图片（宽高未知）居中的效果， 步骤如下，12345678910111213141516171819202122232425&lt;view class='video-one-poster-icon'&gt; &lt;image class='video-one-activity' src='&#123;&#123;xx&#125;&#125;' mode="aspectFill"/&gt; &lt;view class='bg'&gt;&lt;/view&gt; &lt;image class='video-icon' src='/images/video-icon.svg' /&gt;&lt;/view&gt;.bg&#123; width: 100%; height: 100%; position: absolute; left: 0; top: 0; background: #000; opacity: 0.3;&#125;.video-icon&#123; width: 100rpx; height: 100rpx; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);&#125; 善于利用 transform 改变元素大小，移动位置。 css 加边框利用css 给元素加上边框，可以利用下面两种方式实现 border 属性，设定边框宽度，假设要实现上下边框 12border: 1rpx solid rgba(0, 0, 0, 0.15);border-width: 0rpx 0rpx 1rpx 0rpx; 设置 box-shadow ， 阴影矩形会往上下移动 1rpx 123456/* x偏移量 | y偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 */&lt;!-- 这个元素阴影盒子的偏移，正负含义类似 定位的left/top--&gt;box-shadow: 0rpx -1rpx 0rpx 0rpx rgba(0, 0, 0, 0.15);&lt;!-- 把阴影延y 轴下移1rpx --&gt;box-shadow: 0px 1px 0px 0px rgba(0, 0, 0, 0.15) css 加蒙版 滤镜、透明度实现给元素加一层 蒙版12345&lt;!-- 透明度 --&gt;opacity: 0.7&lt;!-- 滤镜--&gt;filter: grayscale(50%) 这就是一些关于学习css 的体会，欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>web</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>伪类</tag>
        <tag>动画</tag>
        <tag>边框</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html/css 写页面]]></title>
    <url>%2F2018%2F09%2F25%2Fhtml%2Bcss%2F</url>
    <content type="text"><![CDATA[用html/css 怎样写出页面呢，看到每个页面都有很多html标签和css 修饰属性，难免会被吓到。其实我们只要从整体到细节，即页面结构到元素来理解页面是如何组合在一起的，就可以入门。 页面是如何组合在一起的首先页面是由html 标签组成的，每个标签都代表一个盒子（如下图），盒子有外边距、边框、内边距、内容宽高等属性。 标签之间可以嵌套 display，决定标签是否独占一行，或者由自身宽高决定所占位置 position，标签在页面位置原本是从上到下排列，但可以改变 比如，下面代码12345678910111213141516&lt;div class='border-show'&gt; div &lt;/div&gt;&lt;div class='border-show'&gt; div &lt;/div&gt;&lt;span class='border-show'&gt;span&lt;/span&gt;&lt;span class='border-show'&gt;span&lt;/span&gt;&lt;style&gt; .border-show &#123; border: 1px solid #000; margin: 50px; padding: 1px; &#125;&lt;/style&gt; 效果如下， display 属性规定元素应该生成的框的类型，明显div 该属性值为block，span 是inline（这是默认值）。可以通过修改display 来改变div 框的类型，常用属性值如，block/inline-block/flex。常用的块级元素有div p form ul ol li等，行内元素span strong等。 position 属性指定一个元素（静态的，相对的，绝对或固定）的定位方法的类型，常用的有： static，默认值，就是按照从上到下的顺序排列页面元素 fixed，指该元素，脱离原本的从上到下的顺序，只以浏览器窗口为参照物，通过 left/top/right/bottom 来控制和浏览器的相对位置。stickly 类似 relative，指该元素，相对从上到下的原本位置进行移动，通过left/top/right/bottom 来控制。注意，元素相对定位移动之后，原来所占位置不会消失。 absolute，指该元素，相对于第一个含（position：除static 外）的父元素进行移动 left/top/right/bottom 的正负值含义如下图 用什么布局写页面利用静态、相对、固定的定位方法，加上flex 弹性布局就可以用html/css 写出页面 学习flex 弹性布局可以参照flex 布局语法篇–by 阮一峰 学完语法之后，强烈建议动手实现骰子的布局，你会发现刚刚的理解并不是这么准确 接下来也可以用flex 布局去实现常用的页面布局，如栅格系统、圣杯布局、垂直居中等 整体到细节理解了页面的布局，就应该去熟悉一下css 在页面元素细节地方是怎样控制的。比如css 选择器、css伪类、css3的新特性 css 系统了解 css 属性参考手册 mozilla.org 我用html+css 简单实现了一下blog 的首页面，效果如下图，勿喷。这是源码 这就是一些关于html/css 写页面的体会，欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>web</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端入门建议]]></title>
    <url>%2F2018%2F09%2F20%2F%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%BB%BA%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[接触了前端，下面记录自己对前端的一点体会。记得大学时候是很害怕写页面的，总被大量标签和css 吓得无从下手，现在看来是由于当初不懂得如何学习新技术，没有给自己定制合适的step by step 入门学习。希望学习前端能开拓自己视野，对技术认识更深一层。 前端入门 Html+css 页面结构，上色(10%)，两周时间差不多就能熟悉。 js(90%)，得花大量的时间。 需要编程思维 简单的框架应用，jQuery + bootstrap，简单逻辑，动画 es6 –&gt; vue(中小company)，react(大company)，angular(国内较少) 完成1 2，可工作，根据熟练程度可达初中级前端工程师的水平。 学习js 需要慢慢积累打好基础，就不难。第一次看觉得懵逼，第二次能理解一些，第三第四次慢慢的明白是怎么回事，这种感觉就对了。 通过上面3步的学习，实现功能是没有问题的。但是没法优化，一般实现方式有 前端方式，比如缓存，压缩，离线存储，加载延迟等。 非前端方式，比如Vue里面 css/js合成一个很大的文件，加载页面有一段空白时间，利用前端方式是没法优化，的需要后端渲染。这是时候要去学习 node.js 前端做什么 偏向设计 html + css + js ps 绘画功底 实现UI设计图 html+ css+ js基础 ps vue/react/angular 会其中一个 npm 包管理工具 游戏，H5/微信小游戏（作业能力必须很强） html + css + 原生js一定要强 Cocos2d.js web storage webGL websocket 偏向后端的前端，全栈–&gt;node工程师 h + c + j node.js mysql monogDB/redis 集群cluster pc前端，类似 钉钉 NW.js 移动端的前端，手机，不想同时开发Android ios App h+C+j 框架 node npm 手机兼容性，屏幕适配（必考必问） 调试chrome 微信小程序 学习方式 查在线资料，看文章或者在线视频，比如麦子学院/极客学院/慕课/极客时间。参考里面的学习步骤，给自己规划适合的step by step 入门实践（很重要） 自学，找一个会的人监督你学习（很重要） 安排任务 解决问题 js基础太差别着急用框架，就算是通过面试，对框架很依赖，也用不好 学习周期别拉太长，写代码写到安心再去睡觉，哈哈 初级–&gt;中级的一些瓶颈 代码质量太差 变量命名 文件目录 代码冗余，只是实现功能 扩展性太差 逻辑不清晰 测着，测着就通了，不想再看自己的代码 定位问题慢 在思维上意识到了阻碍自己进步的地方，会有一种豁然开朗的感觉，但想要有所进步还是得靠实践，可以从下面几点做起： 优化代码，成长更快 优雅代码的养成 可扩展性，1个是1个类型，2个是2个类型，&gt;2就是1个类型 模块化 阅读源码 京东/天猫/携程的页面源码，js/css分开，腾讯不建议（命名奇怪） github上引入插件–使用插件–修改插件 阅读自己曾经嫌弃的框架，bootstrap(透明规范)/jQuery 我觉得在中级会遇到的瓶颈和改善方式不仅适合前端，在其他技术方向也是一样的。中级到高级离自己有距离，不太懂。但从接触的同事建议说， 别框架追星，业务合适才最重要 开阔视野 这就是一些关于学习前端的体会，欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>前端入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 常用操作]]></title>
    <url>%2F2018%2F09%2F09%2Fgit_common_operation%2F</url>
    <content type="text"><![CDATA[Git是流行的分布式项目版本管理系统，利用git flow这个优秀的分支模型可以实现多人合作开发项目；在 githbu上也可以学习其他优秀项目！在这里结合自己使用习惯，总结一下git的常用操作。想详细了解git的开发人员可以参考 廖雪峰git教程 git安装一般是先 下载git客户端，安装好之后在电脑桌面点击右键，能看到Git Bash Here就说明安装成功！在本地利用 git初始化项目，然后再 push到你的 github上。接下来模拟一下这一过程， 在桌面新建文件夹 project 进入 project，点击右键在此目录下进入 git bash 123456789# 设置该git user$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com# 初始化git init# 此时 project内有隐藏文件 .git管理，查看ls -a 编辑文件 12# 创建 1.txt 加入一段文字，也可以采用 vimtouch 1.txt 利用 git status查看项目文件状态，可以显示哪些新增文件，删除文件，或者各个区内的文件状态！ git各区概念git正是利用工作区、暂存区、版本区这三个区来实现分布式管理项目。利用这三个区结合 github就可以实现去中心化，因为每一个开发人员的本地都会有一份项目开发过程的log备份，就算 github挂掉了，只要拿到任何一个开发人员的一份备份也可以还原分布式开发！ 工作区，就是在 project目录下看到的文件，git bash编辑命令 ls -ll 即可看到工作区的文件！ 暂存区，就是 git add [文件名]到的目录区，当需提交的文件量多，可以利用 git add .添加全部文件，同时包括删除操作！执行 add命令，还是显示红色字体，即未添加成功。可能因为某个文件夹内含另外一个被 git管理的目录，删除该目录下隐藏的git 文件即可! 123456# 在 project内利用 `git status`看文件状态# 显示**红色**提示，说明 1.txt未提交到暂存区git add 1.txt# 此时 1.txt已提交到暂存区，查看暂存区目录文件git ls-files 版本区，将暂存区的文件提交到版本区内，git status 显示的蓝色提示，就是说明添加到暂存区的文件未被提交到版本区，commit至版本区。每次 push就是将版本区的文件提交至 github 1git commit -m &apos;[本次提交的注释]&apos; push项目到 github当文件成功commit到版本区之后，git status显示 nothing to commit，接下来将项目 push到github。 在 githbu上注册账号，创建一个仓库 设置提交的远程库，采用 https 协议，origin只是一个名字可以改变 12345# 采用https协议，不要配置公私钥，但每次要输密码git remote add origin https://github.com/lcs1234567/project.git# -u 下次执行git push 就会默认push origingit push -u origin master 亦可以采用ssh协议，因为ssh协议，要配置设备私公钥至github，待私公钥生成，打开存放目录，将公钥复制，添加到你的github，点击头像/setting/SSH and GPG keys，将项目 push到 github。第一次利用ssh push是会提示 authenticity can’t be established，输入yes，回车就可以了！ 123456# 生成设备私公钥, git bash中输入以下命令，一路按回车键ssh-keygen -t rsagit remote add origin git@github.com:lcs1234567/project.gitgit push origin master 在本地git bash可以查看配置好的远程仓库 1git remote -v git 常用命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# 设置 本机git user$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com"# https 协议 和 SSH 协议连接 github 区别# 删除git 本地分支$ git branch -d &lt;branch_name&gt;# 删除github 远程分支$ git push --delete &lt;remote_name&gt; &lt;branch_name&gt;# 本地 创建并切换到该分支 git checkout -b develop# 拉取远程分支，并且切换到该分支（原先本地没该分支）git checkout -b &lt;branch_name&gt; &lt;remote_name&gt;/&lt;branch_name&gt;git checkout -b develop origin/develop或者git checkout -t origin/develop# 查看远程分支git branch -a# 在某个分支上回归版本git log // 查看历史 commitIdgit log --pretty=oneline // 查看当前所在commitIdgit reset --hard &lt;commitId&gt;# git tag 命令git taggit tag 0.0.1git tag -a 0.0.1 -m "version 0.1 released" git tag -a 0.0.1 -m "version 0.1 released" 1094adbgit show 0.0.1# 删除本地taggit tag -d 0.0.1# push taggit push origin 0.0.1git push origin --tags# 删除远程taggit tag -d 0.0.1git push origin :refs/tags/0.0.1 git flow一个人开发时，master/develop 两个分支就可以满足要求。项目组合作就不同了，会出现各种问题。比如 不可能只在develop 开发，今天你在develop 完成需求A，需求B 开发到一半，要求发版本怎么办？ 从develop 迁出分支完需求，怎样分类、明确分支功能。如feature/bugfix 怎样发版本，打tag，线上版本处理bug 怎样快速修复 git flow 该分支模型就是用来解决多人合作开发遇到的问题，理解 gitflow这篇文章足够了 git GUI刚开始我一点也不喜欢git 的图形化界面操作，认为用命令行操作很 cool，但是部门项目开发、测试流程繁琐，并且依赖人工记忆。一般项目环境分为（其中部署可用shell script 做成可视化操作）， 本地开发 内网测试 外网部署，可能有个外测 由于在内网测试的功能不会一定要部署到正式环境，因此部门添加了一个pre-develop 分支，完成需求流程就变成这样， develop 迁出 feature，完成需求，合并到pre-develop 自己将 pre-develop 部署到内网，找验收需求方测试 测试通过，就把feature finish 到 develp，再部署外网。这一步还利用了code review 的步骤，开发人员通过 pull request 提交合并，再由检查你代码写得是否规范的同事完成合并。 如果测试之后有问题需要修改，就必须来回切换分支（流程不能出错）。万一把代码写在错的分支就悲剧了，所以 git GUI sourcetree 能帮我们减轻心智负担，多出时间去完成自己的todo，学习其他技术，锻炼身体，哈哈！ 这就是一些常用的git 管理项目的流程，欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>基础</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 搭建自己的blog]]></title>
    <url>%2F2018%2F08%2F18%2Fbuild_hexo_blog%2F</url>
    <content type="text"><![CDATA[不喜欢新浪、csdn、知乎，简书的博客平台，因为页面有广告，就用hexo框架配合github 搭建了一个自己的blog。希望将自己学习的技术经历总结下来，沉淀自己，也借此和大家一起分享、探讨。 hexo 搭建博客技能需要 了解 git 常用命令和概念 了解 linux 常用命令 安装准备博客页面是先用 md 语法编辑成为文，再由node.js 生成静态html而来，最后部署到github供大家访问。所以需在本地安装 Node.js Git 发布文章参考hexo的官方中文文档，相信你一定能够顺利完成部署之前的任务，本地博文的编辑。一般我的做法是， 利用md 编辑器把博文编辑好 参考官方文档md 文件的书写格式 在博文开头设置 title/data/categories/tags相关属性，如：12345678910title: hexo 搭建自己的blogdate: 2018/8/18categories:- 基础- blogtags:- hexo- gitcomments: true--- 把md 文件copy 至博客根目录的source/_post目录下 在博客根目录打开Git 命令行 hexo g hexo server 在浏览器通过 http://localhost:4000/ 访问博客 若你想删除博文 hexo clean 进入 source/_post 删除该md 文件 通过浏览器访问本地博文，修改至感觉满意之后，可以部署到github 供其他开发人员访问。一般步骤： 在你的github 建立仓库 仓库名，[github username].github.io 如：lcs1234567.github.io 编辑 本地博客根目录下的_config.yml 设置url: https://[github username].github.io 在文件最后添加 deploy 信息， 注意空格。如：1234deploy: type: git repo: git@github.com:lcs1234567/lcs1234567.github.io.git branch: master 由于部署项目到github 用的是ssh协议，非https，需配置私公钥 随便那个目录 打开git 命令行 ssh-keygen -t rsa 一路回车键，待私公钥生成，打开存放目录 将公钥复制，添加到你的github，点击头像/setting/SSH and GPG keys 执行部署命令，本地git命令行 1hexo d 此时可以通过 https://[github username].github.io 访问你的博客！ 设置Next 主题设置博客的主题，我当前选择next，参考 next 文档-中文。这种美化页面的细活，自己耐心做就行了。 实现 多台电脑协作如果你在家用自己的电脑编辑好博文，并通过hexo g -d部署到github；后面你又想在公司写博客、部署，但发现github所存并非源代码，而是生成后的静态文件。 解决这个问题，我一般是在github建立两个分支，打开你的[github username].github.io仓库，当前分支是master，但这是生成后的静态文件。这是因为你在_config.yml里配置了master，每次你hexo g -d 就会将静态文件部署到该分支，以后无需操心。 创建另外一个分支： 在本地博客根目录 打开git 命令行 把本地博客source commit 到版本区 1234567git init git add -Agit status git commit -m &apos;blog files&apos;git remote add hexo git@github.com:lcs1234567/lcs1234567.github.io.gitgit push -u hexo hexo 设置 hexo 为默认分支 点击博客仓库下的setting/Branches 设置默认分支为 hexo 这样以后就默认 clone 该分支，clone下来后，再进入blog根目录 npm install安装依赖 注意，git add -A 时可能目录themes/next 无法被add，这是因为next目录是你clone下来的主题，被另外一个.git/ 管理。我采用简单粗暴方法是在next/ 打开 git bash12ls -arm -rf .git/ 在公司设备 git clone 博客仓库，hexo g -d前再次生成私公钥，因为私公钥是相对设备的，设备换了必须添加该设备的公钥。 添加评论功能评论功能可选择gitalk/valine/来必力，我集成的是valine。 在valine 注册一个应用，查看app id, app key 修改 themes/next 的主题配置文件_config.yml 12345678910valine: enable: true appid: [your app id] appkey: [your app key] notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 参考文章 hexo 官方文档 next 主题配置官方文档 集成 valine评论功能 添加博客主题其他样式 设置博客首页摘要 欢迎大家给我留言，提建议，指出错误，一起讨论学习技术的感受！]]></content>
      <categories>
        <category>基础</category>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
</search>
